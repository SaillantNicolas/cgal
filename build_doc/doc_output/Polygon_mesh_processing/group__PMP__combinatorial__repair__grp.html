<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CGAL 6.0 - Polygon Mesh Processing: Combinatorial Repair</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script src="../Manual/cookie.js" type="text/javascript"></script>
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="topics.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()">&#160;
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)"
               onblur="searchBox.OnSearchFieldFocus(false)"
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""/></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.0 - Polygon Mesh Processing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__PMP__combinatorial__repair__grp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Combinatorial Repair<div class="ingroups"><a class="el" href="group__PkgPolygonMeshProcessingRef.html">Polygon Mesh Processing Reference</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader"> </h2>
<p>Functions to repair polygon soups and polygon meshes. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga121f588ac324938d9a6b6931a08661e1" id="r_ga121f588ac324938d9a6b6931a08661e1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> PolygonMesh &gt; </td></tr>
<tr class="memitem:ga121f588ac324938d9a6b6931a08661e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga121f588ac324938d9a6b6931a08661e1">CGAL::Polygon_mesh_processing::is_non_manifold_vertex</a> (<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> boost::graph_traits&lt; PolygonMesh &gt;::vertex_descriptor <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">v</a>, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> PolygonMesh &amp;pm)</td></tr>
<tr class="memdesc:ga121f588ac324938d9a6b6931a08661e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether a vertex of a polygon mesh is non-manifold.  <br /></td></tr>
<tr class="separator:ga121f588ac324938d9a6b6931a08661e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36098d2415efd0604b7b996163bc22db" id="r_ga36098d2415efd0604b7b996163bc22db"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> PolygonMesh , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">OutputIterator</a> &gt; </td></tr>
<tr class="memitem:ga36098d2415efd0604b7b996163bc22db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">OutputIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga36098d2415efd0604b7b996163bc22db">CGAL::Polygon_mesh_processing::non_manifold_vertices</a> (<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> PolygonMesh &amp;pm, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">OutputIterator</a> out)</td></tr>
<tr class="memdesc:ga36098d2415efd0604b7b996163bc22db"><td class="mdescLeft">&#160;</td><td class="mdescRight">collects the non-manifold vertices (if any) present in the mesh.  <br /></td></tr>
<tr class="separator:ga36098d2415efd0604b7b996163bc22db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25901cbedcc6123d7760ac5b9dc8d14e" id="r_ga25901cbedcc6123d7760ac5b9dc8d14e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> PolygonMesh , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> NamedParameters  = parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga25901cbedcc6123d7760ac5b9dc8d14e"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga25901cbedcc6123d7760ac5b9dc8d14e">CGAL::Polygon_mesh_processing::duplicate_non_manifold_vertices</a> (PolygonMesh &amp;pm, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;np=parameters::default_values())</td></tr>
<tr class="memdesc:ga25901cbedcc6123d7760ac5b9dc8d14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">duplicates all the non-manifold vertices of the input mesh.  <br /></td></tr>
<tr class="separator:ga25901cbedcc6123d7760ac5b9dc8d14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95ff13c1578f509fa8ed58b1884d0e46" id="r_ga95ff13c1578f509fa8ed58b1884d0e46"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">class</a> PolygonMesh , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">class</a> NamedParameters  = parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga95ff13c1578f509fa8ed58b1884d0e46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga95ff13c1578f509fa8ed58b1884d0e46">CGAL::Polygon_mesh_processing::merge_duplicated_vertices_in_boundary_cycle</a> (<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> boost::graph_traits&lt; PolygonMesh &gt;::halfedge_descriptor <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">h</a>, PolygonMesh &amp;pm, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;np=parameters::default_values())</td></tr>
<tr class="memdesc:ga95ff13c1578f509fa8ed58b1884d0e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">merges identical vertices around a cycle of boundary edges.  <br /></td></tr>
<tr class="separator:ga95ff13c1578f509fa8ed58b1884d0e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2af4c26afc4872bafd0caabe6af23f9a" id="r_ga2af4c26afc4872bafd0caabe6af23f9a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">class</a> PolygonMesh , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">class</a> NamedParameters  = parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga2af4c26afc4872bafd0caabe6af23f9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga2af4c26afc4872bafd0caabe6af23f9a">CGAL::Polygon_mesh_processing::merge_duplicated_vertices_in_boundary_cycles</a> (PolygonMesh &amp;pm, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;np=parameters::default_values())</td></tr>
<tr class="memdesc:ga2af4c26afc4872bafd0caabe6af23f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">extracts boundary cycles and merges the duplicated vertices of each cycle.  <br /></td></tr>
<tr class="separator:ga2af4c26afc4872bafd0caabe6af23f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3be94f1f7968022a294dd533400ad554" id="r_ga3be94f1f7968022a294dd533400ad554"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> PolygonMesh , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> NamedParameters  = parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga3be94f1f7968022a294dd533400ad554"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga3be94f1f7968022a294dd533400ad554">CGAL::Polygon_mesh_processing::polygon_mesh_to_polygon_soup</a> (<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> PolygonMesh &amp;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">mesh</a>, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> &amp;points, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> &amp;polygons, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;np=parameters::default_values())</td></tr>
<tr class="memdesc:ga3be94f1f7968022a294dd533400ad554"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds the vertices and faces of a mesh into a (possibly non-empty) polygon soup.  <br /></td></tr>
<tr class="separator:ga3be94f1f7968022a294dd533400ad554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b9d12d817b5cc76f5a42d74eac75bf3" id="r_ga8b9d12d817b5cc76f5a42d74eac75bf3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> &gt; </td></tr>
<tr class="memitem:ga8b9d12d817b5cc76f5a42d74eac75bf3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8b9d12d817b5cc76f5a42d74eac75bf3">CGAL::Polygon_mesh_processing::is_polygon_soup_a_polygon_mesh</a> (<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> &amp;polygons)</td></tr>
<tr class="memdesc:ga8b9d12d817b5cc76f5a42d74eac75bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <code>true</code> if the soup of polygons defines a valid polygon mesh that can be handled by <code><a class="el" href="#ga2ba9722ec8472a1455107ffce7145e46" title="builds a polygon mesh from a soup of polygons.">CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh()</a></code>.  <br /></td></tr>
<tr class="separator:ga8b9d12d817b5cc76f5a42d74eac75bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ba9722ec8472a1455107ffce7145e46" id="r_ga2ba9722ec8472a1455107ffce7145e46"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> PolygonMesh , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">NamedParameters_PS</a>  = parameters::Default_named_parameters, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">NamedParameters_PM</a>  = parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga2ba9722ec8472a1455107ffce7145e46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga2ba9722ec8472a1455107ffce7145e46">CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh</a> (<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> &amp;points, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> &amp;polygons, PolygonMesh &amp;out, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">NamedParameters_PS</a> &amp;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">np_ps</a>=parameters::default_values(), <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">NamedParameters_PM</a> &amp;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">np_pm</a>=parameters::default_values())</td></tr>
<tr class="memdesc:ga2ba9722ec8472a1455107ffce7145e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">builds a polygon mesh from a soup of polygons.  <br /></td></tr>
<tr class="separator:ga2ba9722ec8472a1455107ffce7145e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef5c13fc9dd4cae14c860351c479a45f" id="r_gaef5c13fc9dd4cae14c860351c479a45f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> &gt; </td></tr>
<tr class="memitem:gaef5c13fc9dd4cae14c860351c479a45f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaef5c13fc9dd4cae14c860351c479a45f">CGAL::Polygon_mesh_processing::remove_isolated_points_in_polygon_soup</a> (<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> &amp;points, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> &amp;polygons)</td></tr>
<tr class="memdesc:gaef5c13fc9dd4cae14c860351c479a45f"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes the isolated points from a polygon soup.  <br /></td></tr>
<tr class="separator:gaef5c13fc9dd4cae14c860351c479a45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f215926ed8794db827e2993d2960870" id="r_ga1f215926ed8794db827e2993d2960870"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> NamedParameters  = parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga1f215926ed8794db827e2993d2960870"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1f215926ed8794db827e2993d2960870">CGAL::Polygon_mesh_processing::merge_duplicate_points_in_polygon_soup</a> (<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> &amp;points, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> &amp;polygons, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;np=parameters::default_values())</td></tr>
<tr class="memdesc:ga1f215926ed8794db827e2993d2960870"><td class="mdescLeft">&#160;</td><td class="mdescRight">merges the duplicate points in a polygon soup.  <br /></td></tr>
<tr class="separator:ga1f215926ed8794db827e2993d2960870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93d14c26c259b5844dbd5a7753278e5f" id="r_ga93d14c26c259b5844dbd5a7753278e5f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> NamedParameters  = parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga93d14c26c259b5844dbd5a7753278e5f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga93d14c26c259b5844dbd5a7753278e5f">CGAL::Polygon_mesh_processing::merge_duplicate_polygons_in_polygon_soup</a> (<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> &amp;points, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> &amp;polygons, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;np=parameters::default_values())</td></tr>
<tr class="memdesc:ga93d14c26c259b5844dbd5a7753278e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">merges the duplicate polygons in a polygon soup.  <br /></td></tr>
<tr class="separator:ga93d14c26c259b5844dbd5a7753278e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b35133783759402828325b91ab559cc" id="r_ga3b35133783759402828325b91ab559cc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> NamedParameters  = parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga3b35133783759402828325b91ab559cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga3b35133783759402828325b91ab559cc">CGAL::Polygon_mesh_processing::repair_polygon_soup</a> (<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> &amp;points, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> &amp;polygons, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;np=parameters::default_values())</td></tr>
<tr class="memdesc:ga3b35133783759402828325b91ab559cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">cleans a given polygon soup through various repairing operations.  <br /></td></tr>
<tr class="separator:ga3b35133783759402828325b91ab559cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31bf16dbfb6e46202ca4277df8e69908" id="r_ga31bf16dbfb6e46202ca4277df8e69908"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> PolygonMesh , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> NamedParameters  = CGAL::parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga31bf16dbfb6e46202ca4277df8e69908"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga31bf16dbfb6e46202ca4277df8e69908">CGAL::Polygon_mesh_processing::stitch_boundary_cycle</a> (<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> boost::graph_traits&lt; PolygonMesh &gt;::halfedge_descriptor <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">h</a>, PolygonMesh &amp;pmesh, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;np=parameters::default_values())</td></tr>
<tr class="memdesc:ga31bf16dbfb6e46202ca4277df8e69908"><td class="mdescLeft">&#160;</td><td class="mdescRight">stitches together, whenever possible, two halfedges belonging to the boundary cycle described by the halfedge <code>h</code>.  <br /></td></tr>
<tr class="separator:ga31bf16dbfb6e46202ca4277df8e69908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga621eebea618dc7d2356fa7fddb026905" id="r_ga621eebea618dc7d2356fa7fddb026905"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">BorderHalfedgeRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> PolygonMesh , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> NamedParameters  = CGAL::parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga621eebea618dc7d2356fa7fddb026905"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga621eebea618dc7d2356fa7fddb026905">CGAL::Polygon_mesh_processing::stitch_boundary_cycles</a> (<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">BorderHalfedgeRange</a> &amp;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">boundary_cycle_representatives</a>, PolygonMesh &amp;pmesh, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;np=parameters::default_values())</td></tr>
<tr class="memdesc:ga621eebea618dc7d2356fa7fddb026905"><td class="mdescLeft">&#160;</td><td class="mdescRight">stitches together, whenever possible, two halfedges belonging to the same boundary cycle.  <br /></td></tr>
<tr class="separator:ga621eebea618dc7d2356fa7fddb026905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga152989d1d1edabb9f68296d9395eb2dd" id="r_ga152989d1d1edabb9f68296d9395eb2dd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> PolygonMesh , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">HalfedgePairsRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> NamedParameters  = CGAL::parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga152989d1d1edabb9f68296d9395eb2dd"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga152989d1d1edabb9f68296d9395eb2dd">CGAL::Polygon_mesh_processing::stitch_borders</a> (PolygonMesh &amp;pmesh, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">HalfedgePairsRange</a> &amp;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">hedge_pairs_to_stitch</a>, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;np=parameters::default_values(), std::enable_if_t&lt; boost::has_range_iterator&lt; <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">HalfedgePairsRange</a> &gt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">::value</a> &gt; *=0)</td></tr>
<tr class="memdesc:ga152989d1d1edabb9f68296d9395eb2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">stitches together border halfedges in a polygon mesh.  <br /></td></tr>
<tr class="separator:ga152989d1d1edabb9f68296d9395eb2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga740c417af0ef24a16faebb23727d089c" id="r_ga740c417af0ef24a16faebb23727d089c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> PolygonMesh , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> NamedParameters  = CGAL::parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga740c417af0ef24a16faebb23727d089c"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga740c417af0ef24a16faebb23727d089c">CGAL::Polygon_mesh_processing::stitch_borders</a> (PolygonMesh &amp;pmesh, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;np=parameters::default_values())</td></tr>
<tr class="memdesc:ga740c417af0ef24a16faebb23727d089c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the other overload, but the pairs of halfedges to be stitched are automatically found amongst all border halfedges.  <br /></td></tr>
<tr class="separator:ga740c417af0ef24a16faebb23727d089c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga562d3f935e55a6378d407183f9533dd1" id="r_ga562d3f935e55a6378d407183f9533dd1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">BorderHalfedgeRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> PolygonMesh , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> NamedParameters  = CGAL::parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga562d3f935e55a6378d407183f9533dd1"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga562d3f935e55a6378d407183f9533dd1">CGAL::Polygon_mesh_processing::stitch_borders</a> (<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">BorderHalfedgeRange</a> &amp;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">boundary_cycle_representatives</a>, PolygonMesh &amp;pmesh, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;np=parameters::default_values())</td></tr>
<tr class="memdesc:ga562d3f935e55a6378d407183f9533dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the other overload, but the pairs of halfedges to be stitched are automatically found amongst halfedges in cycles described by <code>boundary_cycle_representatives</code>.  <br /></td></tr>
<tr class="separator:ga562d3f935e55a6378d407183f9533dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga25901cbedcc6123d7760ac5b9dc8d14e" name="ga25901cbedcc6123d7760ac5b9dc8d14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25901cbedcc6123d7760ac5b9dc8d14e">&#9670;&#160;</a></span>duplicate_non_manifold_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> PolygonMesh , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> NamedParameters  = parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t CGAL::Polygon_mesh_processing::duplicate_non_manifold_vertices </td>
          <td>(</td>
          <td class="paramtype">PolygonMesh &amp;</td>          <td class="paramname"><span class="paramname"><em>pm</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>np</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/manifoldness.h&gt;</code></p>

<p>duplicates all the non-manifold vertices of the input mesh. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PolygonMesh</td><td>a model of <code>HalfedgeListGraph</code> and <code>MutableHalfedgeGraph</code> </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>the surface mesh to be repaired </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>pm</code> </li>
<li>
<b>Type: </b>a class model of <code>ReadWritePropertyMap</code> with <code>boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, pm)</code> </li>
<li>
<b>Extra: </b>If this parameter is omitted, an internal property map for <code>CGAL::vertex_point_t</code> must be available in <code>PolygonMesh</code>. </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>vertex_is_constrained_map</b> </button> <div class="content"><ul>
<li>
a property map containing the constrained-or-not status of each vertex of <code>pm</code>. </li>
<li>
<b>Type: </b>a class model of <code>ReadWritePropertyMap</code> with <code>boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor</code> as key type and <code>bool</code> as value type. It must be default constructible. </li>
<li>
<b>Default: </b>a default property map where no vertex is constrained </li>
<li>
<b>Extra: </b><code>put(vcm, v, true)</code> will be called for each duplicated vertices, as well as the original non-manifold vertex in the input mesh. </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>output_iterator</b> </button> <div class="content"><ul>
<li>
an output iterator to collect the duplicated vertices </li>
<li>
<b>Type: </b>a model of <code>OutputIterator</code> with value type <code>std::vector&lt;vertex_descriptor&gt;</code> </li>
<li>
<b>Default: </b>unused </li>
<li>
<b>Extra: </b>The first vertex of each vector is a non-manifold vertex of the input mesh, followed by the new vertices that were created to fix the given non-manifold configuration. </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of vertices created</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ga36098d2415efd0604b7b996163bc22db" title="collects the non-manifold vertices (if any) present in the mesh.">non_manifold_vertices()</a></code> </dd></dl>

</div>
</div>
<a id="ga121f588ac324938d9a6b6931a08661e1" name="ga121f588ac324938d9a6b6931a08661e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga121f588ac324938d9a6b6931a08661e1">&#9670;&#160;</a></span>is_non_manifold_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> PolygonMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">bool</a> CGAL::Polygon_mesh_processing::is_non_manifold_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> boost::graph_traits&lt; PolygonMesh &gt;::vertex_descriptor</td>          <td class="paramname"><span class="paramname"><em>v</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> PolygonMesh &amp;</td>          <td class="paramname"><span class="paramname"><em>pm</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/manifoldness.h&gt;</code></p>

<p>returns whether a vertex of a polygon mesh is non-manifold. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function has linear runtime with respect to the size of the mesh. The function <code><a class="el" href="#ga36098d2415efd0604b7b996163bc22db" title="collects the non-manifold vertices (if any) present in the mesh.">non_manifold_vertices()</a></code> should be used when gathering all non manifold vertices.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PolygonMesh</td><td>a model of <code>HalfedgeListGraph</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a vertex of <code>pm</code> </td></tr>
    <tr><td class="paramname">pm</td><td>a triangle mesh containing <code>v</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the vertex is non-manifold, <code>false</code> otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ga25901cbedcc6123d7760ac5b9dc8d14e" title="duplicates all the non-manifold vertices of the input mesh.">duplicate_non_manifold_vertices()</a></code> </dd></dl>

</div>
</div>
<a id="ga8b9d12d817b5cc76f5a42d74eac75bf3" name="ga8b9d12d817b5cc76f5a42d74eac75bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b9d12d817b5cc76f5a42d74eac75bf3">&#9670;&#160;</a></span>is_polygon_soup_a_polygon_mesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">bool</a> CGAL::Polygon_mesh_processing::is_polygon_soup_a_polygon_mesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>polygons</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/polygon_soup_to_polygon_mesh.h&gt;</code></p>

<p>returns <code>true</code> if the soup of polygons defines a valid polygon mesh that can be handled by <code><a class="el" href="#ga2ba9722ec8472a1455107ffce7145e46" title="builds a polygon mesh from a soup of polygons.">CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh()</a></code>. </p>
<p>It checks that each edge has at most two incident faces and such an edge is visited in opposite direction along the two face boundaries, no polygon has twice the same vertex, and the polygon soup describes a manifold surface. This function does not require a range of points as an argument since the check is purely topological. To each vertex of the mesh is associated an index that is used in the description of the boundaries of the polygons provided in <code>polygons</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PolygonRange</td><td>a model of the concept <code>RandomAccessContainer</code> whose <code>value_type</code> is a model of the concept <code>RandomAccessContainer</code> whose <code>value_type</code> is <code>std::size_t</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygons</td><td>each element in the range describes a polygon using the indices of the vertices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__PMP__orientation__grp.html#gad380465ee62d858d27fab4cfda6c1764" title="tries to consistently orient a soup of polygons in 3D space.">CGAL::Polygon_mesh_processing::orient_polygon_soup()</a></code> </dd></dl>

</div>
</div>
<a id="ga1f215926ed8794db827e2993d2960870" name="ga1f215926ed8794db827e2993d2960870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f215926ed8794db827e2993d2960870">&#9670;&#160;</a></span>merge_duplicate_points_in_polygon_soup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> NamedParameters  = parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t CGAL::Polygon_mesh_processing::merge_duplicate_points_in_polygon_soup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>polygons</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>np</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/repair_polygon_soup.h&gt;</code></p>

<p>merges the duplicate points in a polygon soup. </p>
<p>Note that the index of a point that is merged with another point will thus change in all the polygons that the point appears in.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange</td><td>a model of the concepts <code>SequenceContainer</code> and <code>Swappable</code> whose value type is the point type. </td></tr>
    <tr><td class="paramname">PolygonRange</td><td>a model of the concept <code>RandomAccessContainer</code> whose <code>value_type</code> is itself a model of the concept <code>RandomAccessContainer</code> whose <code>value_type</code> is <code>std::size_t</code>. </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>points of the soup of polygons </td></tr>
    <tr><td class="paramname">polygons</td><td>a vector of polygons. Each element in the vector describes a polygon using the indices of the points in <code>points</code>. </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>The traits class must provide the nested functor <code>Less_xyz_3</code> to compare lexicographically two points a function <code>Less_xyz_3 <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42" title="tests if a set of faces of a triangulated surface mesh self-intersects.">less_xyz_3_object()</a></code>. </li>
<li>
<b>Default: </b>a CGAL Kernel deduced from the point type, using <code>CGAL::Kernel_traits</code> </li>
<li>
<b>Extra: </b>The geometric traits class must be compatible with the vertex point type. </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of removed points</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ga3b35133783759402828325b91ab559cc" title="cleans a given polygon soup through various repairing operations.">repair_polygon_soup()</a></code> </dd></dl>

</div>
</div>
<a id="ga93d14c26c259b5844dbd5a7753278e5f" name="ga93d14c26c259b5844dbd5a7753278e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93d14c26c259b5844dbd5a7753278e5f">&#9670;&#160;</a></span>merge_duplicate_polygons_in_polygon_soup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> NamedParameters  = parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t CGAL::Polygon_mesh_processing::merge_duplicate_polygons_in_polygon_soup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>polygons</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>np</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/repair_polygon_soup.h&gt;</code></p>

<p>merges the duplicate polygons in a polygon soup. </p>
<p>Two polygons are duplicate if they share the same vertices in the same order. Note that the first vertex of the polygon does not matter, that is the triangle <code>0,1,2</code> is a duplicate of the triangle <code>2,0,1</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange</td><td>a model of the concept <code>RandomAccessContainer</code> whose value type is the point type. </td></tr>
    <tr><td class="paramname">PolygonRange</td><td>a model of the concept <code>SequenceContainer</code> whose <code>value_type</code> is itself a model of the concepts <code>RandomAccessContainer</code> and <code>ReversibleContainer</code> whose <code>value_type</code> is <code>std::size_t</code>. </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>points of the soup of polygons </td></tr>
    <tr><td class="paramname">polygons</td><td>a vector of polygons. Each element in the vector describes a polygon using the indices of the points in <code>points</code>. </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>The traits class must provide the nested functor <code>Less_xyz_3</code> to compare lexicographically two points a function <code>Less_xyz_3 <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42" title="tests if a set of faces of a triangulated surface mesh self-intersects.">less_xyz_3_object()</a></code>. </li>
<li>
<b>Default: </b>a CGAL Kernel deduced from the point type, using <code>CGAL::Kernel_traits</code> </li>
<li>
<b>Extra: </b>The geometric traits class must be compatible with the vertex point type. </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>erase_all_duplicates</b> </button> <div class="content"><ul>
<li>
Parameter to indicate, when multiple polygons are duplicates, whether all the duplicate polygons should be removed or if one (arbitrarily chosen) face should be kept. </li>
<li>
<b>Type: </b>Boolean </li>
<li>
<b>Default: </b><code>false</code> </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>require_same_orientation</b> </button> <div class="content"><ul>
<li>
Parameter to indicate if polygon orientation should be taken into account when determining whether two polygons are duplicates, that is, whether e.g. the triangles <code>0,1,2</code> and <code>0,2,1</code> are duplicates. </li>
<li>
<b>Type: </b>Boolean </li>
<li>
<b>Default: </b><code>false</code> </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of removed polygons</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ga3b35133783759402828325b91ab559cc" title="cleans a given polygon soup through various repairing operations.">repair_polygon_soup()</a></code> </dd></dl>

</div>
</div>
<a id="ga95ff13c1578f509fa8ed58b1884d0e46" name="ga95ff13c1578f509fa8ed58b1884d0e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95ff13c1578f509fa8ed58b1884d0e46">&#9670;&#160;</a></span>merge_duplicated_vertices_in_boundary_cycle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">class</a> PolygonMesh , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">class</a> NamedParameters  = parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">void</a> CGAL::Polygon_mesh_processing::merge_duplicated_vertices_in_boundary_cycle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> boost::graph_traits&lt; PolygonMesh &gt;::halfedge_descriptor</td>          <td class="paramname"><span class="paramname"><em>h</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PolygonMesh &amp;</td>          <td class="paramname"><span class="paramname"><em>pm</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>np</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/merge_border_vertices.h&gt;</code></p>

<p>merges identical vertices around a cycle of boundary edges. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PolygonMesh</td><td>a model of <code>FaceListGraph</code> and <code>MutableFaceGraph</code>. </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>a halfedge that belongs to a boundary cycle. </td></tr>
    <tr><td class="paramname">pm</td><td>the polygon mesh which contains the boundary cycle. </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>pm</code> </li>
<li>
<b>Type: </b>a class model of <code>ReadWritePropertyMap</code> with <code>boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, pm)</code> </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ga2af4c26afc4872bafd0caabe6af23f9a" title="extracts boundary cycles and merges the duplicated vertices of each cycle.">merge_duplicated_vertices_in_boundary_cycles()</a></code> </dd></dl>

</div>
</div>
<a id="ga2af4c26afc4872bafd0caabe6af23f9a" name="ga2af4c26afc4872bafd0caabe6af23f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2af4c26afc4872bafd0caabe6af23f9a">&#9670;&#160;</a></span>merge_duplicated_vertices_in_boundary_cycles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">class</a> PolygonMesh , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">class</a> NamedParameters  = parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">void</a> CGAL::Polygon_mesh_processing::merge_duplicated_vertices_in_boundary_cycles </td>
          <td>(</td>
          <td class="paramtype">PolygonMesh &amp;</td>          <td class="paramname"><span class="paramname"><em>pm</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>np</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/merge_border_vertices.h&gt;</code></p>

<p>extracts boundary cycles and merges the duplicated vertices of each cycle. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PolygonMesh</td><td>a model of <code>FaceListGraph</code> and <code>MutableFaceGraph</code>. </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>the polygon mesh which contains the cycles. </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>pm</code> </li>
<li>
<b>Type: </b>a class model of <code>ReadWritePropertyMap</code> with <code>boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, pm)</code> </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ga95ff13c1578f509fa8ed58b1884d0e46" title="merges identical vertices around a cycle of boundary edges.">merge_duplicated_vertices_in_boundary_cycle()</a></code> </dd></dl>

</div>
</div>
<a id="ga36098d2415efd0604b7b996163bc22db" name="ga36098d2415efd0604b7b996163bc22db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36098d2415efd0604b7b996163bc22db">&#9670;&#160;</a></span>non_manifold_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> PolygonMesh , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">OutputIterator</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">OutputIterator</a> CGAL::Polygon_mesh_processing::non_manifold_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> PolygonMesh &amp;</td>          <td class="paramname"><span class="paramname"><em>pm</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">OutputIterator</a></td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/manifoldness.h&gt;</code></p>

<p>collects the non-manifold vertices (if any) present in the mesh. </p>
<p>A non-manifold vertex <code>v</code> is returned via one incident halfedge <code>h</code> such that <code>target(h, pm) = v</code> for all the umbrellas that <code>v</code> appears in (an <em>umbrella</em> being the set of faces incident to all the halfedges reachable by walking around <code>v</code> using <code>hnext = prev(opposite(h, pm), pm)</code>, starting from <code>h</code>).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PolygonMesh</td><td>a model of <code>HalfedgeListGraph</code> </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of <code>OutputIterator</code> holding objects of type <code>boost::graph_traits&lt;PolygonMesh&gt;::halfedge_descriptor</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>a triangle mesh </td></tr>
    <tr><td class="paramname">out</td><td>the output iterator that collects halfedges incident to <code>v</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output iterator</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ga121f588ac324938d9a6b6931a08661e1" title="returns whether a vertex of a polygon mesh is non-manifold.">is_non_manifold_vertex()</a></code> </dd>
<dd>
<code><a class="el" href="#ga25901cbedcc6123d7760ac5b9dc8d14e" title="duplicates all the non-manifold vertices of the input mesh.">duplicate_non_manifold_vertices()</a></code> </dd></dl>

</div>
</div>
<a id="ga3be94f1f7968022a294dd533400ad554" name="ga3be94f1f7968022a294dd533400ad554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3be94f1f7968022a294dd533400ad554">&#9670;&#160;</a></span>polygon_mesh_to_polygon_soup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> PolygonMesh , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> NamedParameters  = parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">void</a> CGAL::Polygon_mesh_processing::polygon_mesh_to_polygon_soup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> PolygonMesh &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>polygons</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>np</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/polygon_mesh_to_polygon_soup.h&gt;</code></p>

<p>adds the vertices and faces of a mesh into a (possibly non-empty) polygon soup. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PolygonMesh</td><td>a model of <code>FaceListGraph</code> </td></tr>
    <tr><td class="paramname">PointRange</td><td>a model of the concepts <code>RandomAccessContainer</code> and <code>BackInsertionSequence</code> whose value type can be constructed from the point type of the polygon mesh </td></tr>
    <tr><td class="paramname">PolygonRange</td><td>a model of the concepts <code>RandomAccessContainer</code> and <code>BackInsertionSequence</code> whose value type is itself a model of the concepts <code>RandomAccessContainer</code> and <code>BackInsertionSequence</code> whose value type is <code>std::size_t</code> </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>the mesh whose faces are being put in the polygon soup </td></tr>
    <tr><td class="paramname">points</td><td>points making the polygons of the soup </td></tr>
    <tr><td class="paramname">polygons</td><td>each element in the vector describes a polygon using the indices of the points in <code>points</code> </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>mesh</code> </li>
<li>
<b>Type: </b>a class model of <code>ReadablePropertyMap</code> with <code>boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, mesh)</code> </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
 <div class="CGALAdvanced"> <div>Advanced</div> <p><code>PolygonRange</code> can also be a model of the concepts <code>RandomAccessContainer</code> and <code>BackInsertionSequence</code> whose value type is an array, but it is the user's responsibility to ensure that all faces have the same number of vertices, and that this number is equal to the size of the array. </p> </div> <dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__PMP__orientation__grp.html#gad380465ee62d858d27fab4cfda6c1764" title="tries to consistently orient a soup of polygons in 3D space.">CGAL::Polygon_mesh_processing::orient_polygon_soup()</a></code> </dd>
<dd>
<code><a class="el" href="#ga8b9d12d817b5cc76f5a42d74eac75bf3" title="returns true if the soup of polygons defines a valid polygon mesh that can be handled by CGAL::Polygo...">CGAL::Polygon_mesh_processing::is_polygon_soup_a_polygon_mesh()</a></code> </dd>
<dd>
<code><a class="el" href="#ga2ba9722ec8472a1455107ffce7145e46" title="builds a polygon mesh from a soup of polygons.">CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh()</a></code> </dd></dl>

</div>
</div>
<a id="ga2ba9722ec8472a1455107ffce7145e46" name="ga2ba9722ec8472a1455107ffce7145e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ba9722ec8472a1455107ffce7145e46">&#9670;&#160;</a></span>polygon_soup_to_polygon_mesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> PolygonMesh , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">NamedParameters_PS</a>  = parameters::Default_named_parameters, <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">NamedParameters_PM</a>  = parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">void</a> CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>polygons</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PolygonMesh &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">NamedParameters_PS</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>np_ps</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">NamedParameters_PM</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>np_pm</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/polygon_soup_to_polygon_mesh.h&gt;</code></p>

<p>builds a polygon mesh from a soup of polygons. </p>
<dl class="section pre"><dt>Precondition</dt><dd>the input polygon soup describes a consistently oriented polygon mesh. This can be checked using the function <a class="el" href="#ga8b9d12d817b5cc76f5a42d74eac75bf3"><code>CGAL::Polygon_mesh_processing::is_polygon_soup_a_polygon_mesh(polygons)</code> </a>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PolygonMesh</td><td>a model of <code>MutableFaceGraph</code> </td></tr>
    <tr><td class="paramname">PointRange</td><td>a model of the concept <code>RandomAccessContainer</code> whose value type is the point type </td></tr>
    <tr><td class="paramname">PolygonRange</td><td>a model of the concept <code>RandomAccessContainer</code> whose value type is a model of the concept <code>RandomAccessContainer</code> whose value type is <code>std::size_t</code> </td></tr>
    <tr><td class="paramname">NamedParameters_PS</td><td>a sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> </td></tr>
    <tr><td class="paramname">NamedParameters_PM</td><td>a sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>points of the soup of polygons </td></tr>
    <tr><td class="paramname">polygons</td><td>each element in the range describes a polygon using the indices of the points in <code>points</code> </td></tr>
    <tr><td class="paramname">out</td><td>the polygon mesh to be built </td></tr>
    <tr><td class="paramname">np_ps</td><td>an optional sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the elements of the range <code>points</code> </li>
<li>
<b>Type: </b>a model of <code>ReadablePropertyMap</code> whose value type is a point type convertible to the point type of the vertex point map associated to the polygon mesh </li>
<li>
<b>Default: </b><code>CGAL::Identity_property_map</code> </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>point_to_vertex_output_iterator</b> </button> <div class="content"><ul>
<li>
an <code>OutputIterator</code> containing the pairs source-vertex-index from <code>points</code>, target-vertex. </li>
<li>
<b>Type: </b>a class model of <code>OutputIterator</code> accepting <code>std::pair&lt;int, boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor&gt;</code> </li>
<li>
<b>Default: </b><code>Emptyset_iterator</code> </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>polygon_to_face_output_iterator</b> </button> <div class="content"><ul>
<li>
an <code>OutputIterator</code> containing the pairs polygon-index from <code>polygons</code>, target-face. </li>
<li>
<b>Type: </b>a class model of <code>OutputIterator</code> accepting <code>std::pair&lt;int, boost::graph_traits&lt;PolygonMesh&gt;::face_descriptor&gt;</code> </li>
<li>
<b>Default: </b><code>Emptyset_iterator</code> </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>point_to_vertex_map</b> </button> <div class="content"><ul>
<li>
a property map associating each soup point of <code>points</code> to a vertex of <code>out</code>. </li>
<li>
<b>Type: </b>a class model of <code>ReadablePropertyMap</code> with an integer type as key type and <code>boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor</code> as value type. </li>
<li>
<b>Default: </b>unused </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>polygon_to_face_map</b> </button> <div class="content"><ul>
<li>
a property map associating each soup polygon of <code>polygons</code> to a face of <code>out</code> </li>
<li>
<b>Type: </b>a class model of <code>ReadablePropertyMap</code> with an integer type as key type and <code>boost::graph_traits&lt;PolygonMesh&gt;::face_descriptor</code> as value type. </li>
<li>
<b>Default: </b>unused </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">np_pm</td><td>an optional sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>out</code> </li>
<li>
<b>Type: </b>a class model of <code>ReadWritePropertyMap</code> with <code>boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, out)</code> </li>
<li>
<b>Extra: </b>If this parameter is omitted, an internal property map for <code>CGAL::vertex_point_t</code> must be available in <code>PolygonMesh</code>. </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__PMP__orientation__grp.html#gad380465ee62d858d27fab4cfda6c1764" title="tries to consistently orient a soup of polygons in 3D space.">CGAL::Polygon_mesh_processing::orient_polygon_soup()</a></code> </dd>
<dd>
<code><a class="el" href="#ga8b9d12d817b5cc76f5a42d74eac75bf3" title="returns true if the soup of polygons defines a valid polygon mesh that can be handled by CGAL::Polygo...">CGAL::Polygon_mesh_processing::is_polygon_soup_a_polygon_mesh()</a></code> </dd>
<dd>
<code><a class="el" href="#ga3be94f1f7968022a294dd533400ad554" title="adds the vertices and faces of a mesh into a (possibly non-empty) polygon soup.">CGAL::Polygon_mesh_processing::polygon_mesh_to_polygon_soup()</a></code> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Polygon_mesh_processing_2orient_polygon_soup_example_8cpp-example.html#a2">Polygon_mesh_processing/orient_polygon_soup_example.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gaef5c13fc9dd4cae14c860351c479a45f" name="gaef5c13fc9dd4cae14c860351c479a45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef5c13fc9dd4cae14c860351c479a45f">&#9670;&#160;</a></span>remove_isolated_points_in_polygon_soup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t CGAL::Polygon_mesh_processing::remove_isolated_points_in_polygon_soup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>polygons</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/repair_polygon_soup.h&gt;</code></p>

<p>removes the isolated points from a polygon soup. </p>
<p>A point is considered <em>isolated</em> if it does not appear in any polygon of the soup.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange</td><td>a model of the concept <code>SequenceContainer</code> whose value type is the point type. </td></tr>
    <tr><td class="paramname">PolygonRange</td><td>a model of the concept <code>RandomAccessContainer</code> whose <code>value_type</code> is itself a model of the concept <code>RandomAccessContainer</code> whose <code>value_type</code> is <code>std::size_t</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>points of the soup of polygons </td></tr>
    <tr><td class="paramname">polygons</td><td>a vector of polygons. Each element in the vector describes a polygon using the indices of the points in <code>points</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of removed isolated points</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ga3b35133783759402828325b91ab559cc" title="cleans a given polygon soup through various repairing operations.">repair_polygon_soup()</a></code> </dd></dl>

</div>
</div>
<a id="ga3b35133783759402828325b91ab559cc" name="ga3b35133783759402828325b91ab559cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b35133783759402828325b91ab559cc">&#9670;&#160;</a></span>repair_polygon_soup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> NamedParameters  = parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">void</a> CGAL::Polygon_mesh_processing::repair_polygon_soup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">PolygonRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>polygons</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>np</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/repair_polygon_soup.h&gt;</code></p>

<p>cleans a given polygon soup through various repairing operations. </p>
<p>More precisely, this function carries out the following tasks, in the same order as they are listed:</p><ul>
<li>merging of duplicate points, using the function <code><a class="el" href="#ga1f215926ed8794db827e2993d2960870" title="merges the duplicate points in a polygon soup.">CGAL::Polygon_mesh_processing::merge_duplicate_points_in_polygon_soup()</a></code>;</li>
<li>simplification of polygons to remove geometrically identical consecutive vertices;</li>
<li>splitting of "pinched" polygons, that is polygons in which a geometric position appears more than once. The splitting process results in multiple non-pinched polygons;</li>
<li>removal of invalid polygons, that is polygons with fewer than 2 vertices;</li>
<li>removal of duplicate polygons, using the function <code><a class="el" href="#ga93d14c26c259b5844dbd5a7753278e5f" title="merges the duplicate polygons in a polygon soup.">CGAL::Polygon_mesh_processing::merge_duplicate_polygons_in_polygon_soup()</a></code>;</li>
<li>removal of isolated points, using the function <code><a class="el" href="#gaef5c13fc9dd4cae14c860351c479a45f" title="removes the isolated points from a polygon soup.">CGAL::Polygon_mesh_processing::remove_isolated_points_in_polygon_soup()</a></code>.</li>
</ul>
<p>Note that the point and polygon containers will be modified by the repairing operations, and thus the indexing of the polygons will also be changed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange</td><td>a model of the concepts <code>SequenceContainer</code> and <code>Swappable</code> and whose value type is the point type. </td></tr>
    <tr><td class="paramname">PolygonRange</td><td>a model of the concept <code>SequenceContainer</code> whose <code>value_type</code> is itself a model of the concepts <code>SequenceContainer</code>, <code>Swappable</code>, and <code>ReversibleContainer</code> whose <code>value_type</code> is <code>std::size_t</code>. </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>points of the soup of polygons </td></tr>
    <tr><td class="paramname">polygons</td><td>a vector of polygons. Each element in the vector describes a polygon using the indices of the points in <code>points</code>. </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>The traits class must provide the nested functors <code>Less_xyz_3</code> and <code>Equal_3</code> to respectivelycompare lexicographically two points and to check if two points are identical. For each functor <code>Foo</code>, a function <code>Foo <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42" title="tests if a set of faces of a triangulated surface mesh self-intersects.">foo_object()</a></code> must be provided. </li>
<li>
<b>Default: </b>a CGAL Kernel deduced from the point type, using <code>CGAL::Kernel_traits</code> </li>
<li>
<b>Extra: </b>The geometric traits class must be compatible with the vertex point type. </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>erase_all_duplicates</b> </button> <div class="content"><ul>
<li>
Parameter to indicate, when multiple polygons are duplicates, whether all the duplicate polygons should be removed or if one (arbitrarily chosen) face should be kept. </li>
<li>
<b>Type: </b>Boolean </li>
<li>
<b>Default: </b><code>false</code> </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>require_same_orientation</b> </button> <div class="content"><ul>
<li>
Parameter to indicate if polygon orientation should be taken into account when determining whether two polygons are duplicates, that is, whether e.g. the triangles <code>0,1,2</code> and <code>0,2,1</code> are duplicates. </li>
<li>
<b>Type: </b>Boolean </li>
<li>
<b>Default: </b><code>false</code> </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a id="ga562d3f935e55a6378d407183f9533dd1" name="ga562d3f935e55a6378d407183f9533dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga562d3f935e55a6378d407183f9533dd1">&#9670;&#160;</a></span>stitch_borders() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">BorderHalfedgeRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> PolygonMesh , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> NamedParameters  = CGAL::parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t CGAL::Polygon_mesh_processing::stitch_borders </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">BorderHalfedgeRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>boundary_cycle_representatives</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PolygonMesh &amp;</td>          <td class="paramname"><span class="paramname"><em>pmesh</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>np</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/stitch_borders.h&gt;</code></p>

<p>Same as the other overload, but the pairs of halfedges to be stitched are automatically found amongst halfedges in cycles described by <code>boundary_cycle_representatives</code>. </p>
<p>Two border halfedges <code>h1</code> and <code>h2</code> are set to be stitched if the points associated to the source and target vertices of <code>h1</code> are the same as those of the target and source vertices of <code>h2</code>, respectively.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BorderHalfedgeRange</td><td>a model of <code>Range</code> with value type <code>boost::graph_traits&lt;PolygonMesh&gt;::halfedge_descriptor</code> </td></tr>
    <tr><td class="paramname">PolygonMesh</td><td>a model of <code>FaceListGraph</code> and <code>MutableFaceGraph</code> </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundary_cycle_representatives</td><td>a range of border halfedges, each describing a boundary cycle whose halfedges will be considered for stitching </td></tr>
    <tr><td class="paramname">pmesh</td><td>the polygon mesh to be modified by the stitching procedure </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>apply_per_connected_component</b> </button> <div class="content"><ul>
<li>
specifies if the borders should only be stitched only within their own connected component. </li>
<li>
<b>Type: </b>Boolean </li>
<li>
<b>Default: </b><code>false</code> </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>face_index_map</b> </button> <div class="content"><ul>
<li>
a property map associating to each face of <code>pmesh</code> a unique index between <code>0</code> and <code>num_faces(pmesh) - 1</code> </li>
<li>
<b>Type: </b>a class model of <code>ReadablePropertyMap</code> with <code>boost::graph_traits&lt;PolygonMesh&gt;::face_descriptor</code> as key type and <code>std::size_t</code> as value type </li>
<li>
<b>Default: </b>an automatically indexed internal map </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>pmesh</code> </li>
<li>
<b>Type: </b>a class model of <code>ReadWritePropertyMap</code> with <code>boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, pmesh)</code> </li>
<li>
<b>Extra: </b>If this parameter is omitted, an internal property map for <code>CGAL::vertex_point_t</code> must be available in <code>PolygonMesh</code>. </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>The traits class must provide the nested type <code>Point_3</code>, and the nested functors:<ul>
<li><code>Less_xyz_3</code> to compare lexicographically two points</li>
<li><code>Equal_3</code> to check whether two points are identical. For each functor <code>Foo</code>, a function <code>Foo <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42" title="tests if a set of faces of a triangulated surface mesh self-intersects.">foo_object()</a></code> must be provided. </li>
</ul>
</li>
<li>
<b>Default: </b>a CGAL Kernel deduced from the point type, using <code>CGAL::Kernel_traits</code> </li>
<li>
<b>Extra: </b>The geometric traits class must be compatible with the vertex point type. </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of pairs of halfedges that were stitched.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ga31bf16dbfb6e46202ca4277df8e69908" title="stitches together, whenever possible, two halfedges belonging to the boundary cycle described by the ...">stitch_boundary_cycle()</a></code> </dd>
<dd>
<code><a class="el" href="#ga621eebea618dc7d2356fa7fddb026905" title="stitches together, whenever possible, two halfedges belonging to the same boundary cycle.">stitch_boundary_cycles()</a></code> </dd></dl>

</div>
</div>
<a id="ga152989d1d1edabb9f68296d9395eb2dd" name="ga152989d1d1edabb9f68296d9395eb2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga152989d1d1edabb9f68296d9395eb2dd">&#9670;&#160;</a></span>stitch_borders() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> PolygonMesh , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">HalfedgePairsRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> NamedParameters  = CGAL::parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t CGAL::Polygon_mesh_processing::stitch_borders </td>
          <td>(</td>
          <td class="paramtype">PolygonMesh &amp;</td>          <td class="paramname"><span class="paramname"><em>pmesh</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">HalfedgePairsRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>hedge_pairs_to_stitch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>np</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; boost::has_range_iterator&lt; <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">HalfedgePairsRange</a> &gt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">::value</a> &gt; *</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/stitch_borders.h&gt;</code></p>

<p>stitches together border halfedges in a polygon mesh. </p>
<p>The halfedges to be stitched are provided in <code>hedge_pairs_to_stitch</code>. For each pair <code>p</code> in this vector, <code>p.second</code> and its opposite will be removed from <code>pmesh</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PolygonMesh</td><td>a model of <code>MutableFaceGraph</code> </td></tr>
    <tr><td class="paramname">HalfedgePairsRange</td><td>a range of <code>std::pair&lt;boost::graph_traits&lt;PolygonMesh&gt;::halfedge_descriptor, boost::graph_traits&lt;PolygonMesh&gt;::halfedge_descriptor&gt;</code>, model of <code>Range</code>. Its iterator type is <code>InputIterator</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmesh</td><td>the polygon mesh to be modified by stitching </td></tr>
    <tr><td class="paramname">hedge_pairs_to_stitch</td><td>a range of <code>std::pair</code> of halfedges to be stitched together </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>pm</code> </li>
<li>
<b>Type: </b>a class model of <code>ReadWritePropertyMap</code> with <code>boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, pmesh)</code> </li>
<li>
<b>Extra: </b>If this parameter is omitted, an internal property map for <code>CGAL::vertex_point_t</code> must be available in <code>PolygonMesh</code>. </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of pairs of halfedges that were stitched.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ga31bf16dbfb6e46202ca4277df8e69908" title="stitches together, whenever possible, two halfedges belonging to the boundary cycle described by the ...">stitch_boundary_cycle()</a></code> </dd>
<dd>
<code><a class="el" href="#ga621eebea618dc7d2356fa7fddb026905" title="stitches together, whenever possible, two halfedges belonging to the same boundary cycle.">stitch_boundary_cycles()</a></code> </dd></dl>

</div>
</div>
<a id="ga740c417af0ef24a16faebb23727d089c" name="ga740c417af0ef24a16faebb23727d089c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga740c417af0ef24a16faebb23727d089c">&#9670;&#160;</a></span>stitch_borders() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> PolygonMesh , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> NamedParameters  = CGAL::parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t CGAL::Polygon_mesh_processing::stitch_borders </td>
          <td>(</td>
          <td class="paramtype">PolygonMesh &amp;</td>          <td class="paramname"><span class="paramname"><em>pmesh</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>np</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/stitch_borders.h&gt;</code></p>

<p>Same as the other overload, but the pairs of halfedges to be stitched are automatically found amongst all border halfedges. </p>
<p>Two border halfedges <code>h1</code> and <code>h2</code> are set to be stitched if the points associated to the source and target vertices of <code>h1</code> are the same as those of the target and source vertices of <code>h2</code>, respectively.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BorderHalfedgeRange</td><td>a model of <code>Range</code> with value type <code>boost::graph_traits&lt;PolygonMesh&gt;::halfedge_descriptor</code> </td></tr>
    <tr><td class="paramname">PolygonMesh</td><td>a model of <code>FaceListGraph</code> and <code>MutableFaceGraph</code> </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmesh</td><td>the polygon mesh to be modified by the stitching procedure </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>pmesh</code> </li>
<li>
<b>Type: </b>a class model of <code>ReadWritePropertyMap</code> with <code>boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, pmesh)</code> </li>
<li>
<b>Extra: </b>If this parameter is omitted, an internal property map for <code>CGAL::vertex_point_t</code> must be available in <code>PolygonMesh</code>. </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>apply_per_connected_component</b> </button> <div class="content"><ul>
<li>
specifies if the borders should only be stitched only within their own connected component. </li>
<li>
<b>Type: </b>Boolean </li>
<li>
<b>Default: </b><code>false</code> </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>face_index_map</b> </button> <div class="content"><ul>
<li>
a property map associating to each face of <code>pmesh</code> a unique index between <code>0</code> and <code>num_faces(pmesh) - 1</code> </li>
<li>
<b>Type: </b>a class model of <code>ReadablePropertyMap</code> with <code>boost::graph_traits&lt;PolygonMesh&gt;::face_descriptor</code> as key type and <code>std::size_t</code> as value type </li>
<li>
<b>Default: </b>an automatically indexed internal map </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of pairs of halfedges that were stitched.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ga31bf16dbfb6e46202ca4277df8e69908" title="stitches together, whenever possible, two halfedges belonging to the boundary cycle described by the ...">stitch_boundary_cycle()</a></code> </dd>
<dd>
<code><a class="el" href="#ga621eebea618dc7d2356fa7fddb026905" title="stitches together, whenever possible, two halfedges belonging to the same boundary cycle.">stitch_boundary_cycles()</a></code> </dd></dl>

</div>
</div>
<a id="ga31bf16dbfb6e46202ca4277df8e69908" name="ga31bf16dbfb6e46202ca4277df8e69908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31bf16dbfb6e46202ca4277df8e69908">&#9670;&#160;</a></span>stitch_boundary_cycle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> PolygonMesh , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> NamedParameters  = CGAL::parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t CGAL::Polygon_mesh_processing::stitch_boundary_cycle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> boost::graph_traits&lt; PolygonMesh &gt;::halfedge_descriptor</td>          <td class="paramname"><span class="paramname"><em>h</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PolygonMesh &amp;</td>          <td class="paramname"><span class="paramname"><em>pmesh</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>np</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/stitch_borders.h&gt;</code></p>

<p>stitches together, whenever possible, two halfedges belonging to the boundary cycle described by the halfedge <code>h</code>. </p>
<p>Two border halfedges <code>h1</code> and <code>h2</code> can be stitched if the points associated to the source and target vertices of <code>h1</code> are the same as those of the target and source vertices of <code>h2</code>, respectively.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PolygonMesh</td><td>a model of <code>MutableFaceGraph</code> </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>a border halfedge of the polygon mesh <code>pmesh</code> </td></tr>
    <tr><td class="paramname">pmesh</td><td>the polygon mesh to be stitched </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>pm</code> </li>
<li>
<b>Type: </b>a class model of <code>ReadWritePropertyMap</code> with <code>boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, pmesh)</code> </li>
<li>
<b>Extra: </b>If this parameter is omitted, an internal property map for <code>CGAL::vertex_point_t</code> must be available in <code>PolygonMesh</code>. </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>The traits class must provide the nested type <code>Point_3</code>, and the nested functors:<ul>
<li><code>Less_xyz_3</code> to compare lexicographically two points</li>
<li><code>Equal_3</code> to check whether two points are identical. For each functor <code>Foo</code>, a function <code>Foo <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42" title="tests if a set of faces of a triangulated surface mesh self-intersects.">foo_object()</a></code> must be provided. </li>
</ul>
</li>
<li>
<b>Default: </b>a CGAL Kernel deduced from the point type, using <code>CGAL::Kernel_traits</code> </li>
<li>
<b>Extra: </b>The geometric traits class must be compatible with the vertex point type. </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of pairs of halfedges that were stitched.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ga621eebea618dc7d2356fa7fddb026905" title="stitches together, whenever possible, two halfedges belonging to the same boundary cycle.">stitch_boundary_cycles()</a></code> </dd>
<dd>
<code><a class="el" href="#ga152989d1d1edabb9f68296d9395eb2dd" title="stitches together border halfedges in a polygon mesh.">stitch_borders()</a></code> </dd></dl>

</div>
</div>
<a id="ga621eebea618dc7d2356fa7fddb026905" name="ga621eebea618dc7d2356fa7fddb026905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga621eebea618dc7d2356fa7fddb026905">&#9670;&#160;</a></span>stitch_boundary_cycles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">BorderHalfedgeRange</a> , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> PolygonMesh , <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">typename</a> NamedParameters  = CGAL::parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t CGAL::Polygon_mesh_processing::stitch_boundary_cycles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">BorderHalfedgeRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>boundary_cycle_representatives</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PolygonMesh &amp;</td>          <td class="paramname"><span class="paramname"><em>pmesh</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>np</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/stitch_borders.h&gt;</code></p>

<p>stitches together, whenever possible, two halfedges belonging to the same boundary cycle. </p>
<p>Two border halfedges <code>h1</code> and <code>h2</code> can be stitched if the points associated to the source and target vertices of <code>h1</code> are the same as those of the target and source vertices of <code>h2</code>, respectively.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BorderHalfedgeRange</td><td>a model of <code>Range</code> with value type <code>boost::graph_traits&lt;PolygonMesh&gt;::halfedge_descriptor</code> </td></tr>
    <tr><td class="paramname">PolygonMesh</td><td>a model of <code>MutableFaceGraph</code> </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundary_cycle_representatives</td><td>a range of border halfedges, each describing a boundary cycle of the mesh <code>pmesh</code> </td></tr>
    <tr><td class="paramname">pmesh</td><td>the polygon mesh to be modified by stitching </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>pm</code> </li>
<li>
<b>Type: </b>a class model of <code>ReadWritePropertyMap</code> with <code>boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, pmesh)</code> </li>
<li>
<b>Extra: </b>If this parameter is omitted, an internal property map for <code>CGAL::vertex_point_t</code> must be available in <code>PolygonMesh</code>. </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>The traits class must provide the nested type <code>Point_3</code>, and the nested functors:<ul>
<li><code>Less_xyz_3</code> to compare lexicographically two points</li>
<li><code>Equal_3</code> to check whether two points are identical. For each functor <code>Foo</code>, a function <code>Foo <a class="el" href="group__PMP__intersection__grp.html#ga10428990783d0fc500bb1be8e5d10a42" title="tests if a set of faces of a triangulated surface mesh self-intersects.">foo_object()</a></code> must be provided. </li>
</ul>
</li>
<li>
<b>Default: </b>a CGAL Kernel deduced from the point type, using <code>CGAL::Kernel_traits</code> </li>
<li>
<b>Extra: </b>The geometric traits class must be compatible with the vertex point type. </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of pairs of halfedges that were stitched.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ga31bf16dbfb6e46202ca4277df8e69908" title="stitches together, whenever possible, two halfedges belonging to the boundary cycle described by the ...">stitch_boundary_cycle()</a></code> </dd>
<dd>
<code><a class="el" href="#ga152989d1d1edabb9f68296d9395eb2dd" title="stitches together border halfedges in a polygon mesh.">stitch_borders()</a></code> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</div>
</body>
</html>
