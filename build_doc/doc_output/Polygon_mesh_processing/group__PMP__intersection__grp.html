<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CGAL 6.0 - Polygon Mesh Processing: Intersection Functions</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script src="../Manual/cookie.js" type="text/javascript"></script>
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="topics.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()">&#160;
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)"
               onblur="searchBox.OnSearchFieldFocus(false)"
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""/></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.0 - Polygon Mesh Processing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__PMP__intersection__grp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Intersection Functions<div class="ingroups"><a class="el" href="group__PkgPolygonMeshProcessingRef.html">Polygon Mesh Processing Reference</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader"> </h2>
<p>Functions to test if there are self intersections, and to report faces that do intersect. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2cb4019111658999234b3e377e3eabcd" id="r_ga2cb4019111658999234b3e377e3eabcd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PolylineRange</a> &gt; </td></tr>
<tr class="memitem:ga2cb4019111658999234b3e377e3eabcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga2cb4019111658999234b3e377e3eabcd">CGAL::Polygon_mesh_processing::do_intersect</a> (<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PolylineRange</a> &amp;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">polylines1</a>, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PolylineRange</a> &amp;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">polylines2</a>)</td></tr>
<tr class="memdesc:ga2cb4019111658999234b3e377e3eabcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <code>true</code> if there exists a segment of a polyline of <code>polylines1</code> and a segment of a polyline of <code>polylines2</code> which intersect, and <code>false</code> otherwise.  <br /></td></tr>
<tr class="separator:ga2cb4019111658999234b3e377e3eabcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga202575b5d28a41b7246e60e1be95a1ae" id="r_ga202575b5d28a41b7246e60e1be95a1ae"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Polyline</a> &gt; </td></tr>
<tr class="memitem:ga202575b5d28a41b7246e60e1be95a1ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga202575b5d28a41b7246e60e1be95a1ae">CGAL::Polygon_mesh_processing::do_intersect</a> (<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Polyline</a> &amp;polyline1, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Polyline</a> &amp;polyline2)</td></tr>
<tr class="memdesc:ga202575b5d28a41b7246e60e1be95a1ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <code>true</code> if there exists a segment of <code>polyline1</code> and a segment of <code>polyline2</code> which intersect, and <code>false</code> otherwise.  <br /></td></tr>
<tr class="separator:ga202575b5d28a41b7246e60e1be95a1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga362b69dbf22a03e5a852e5b2efe47e12" id="r_ga362b69dbf22a03e5a852e5b2efe47e12"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> TriangleMesh , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">NamedParameters1</a>  = CGAL::parameters::Default_named_parameter, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">NamedParameters2</a>  = CGAL::parameters::Default_named_parameter&gt; </td></tr>
<tr class="memitem:ga362b69dbf22a03e5a852e5b2efe47e12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga362b69dbf22a03e5a852e5b2efe47e12">CGAL::Polygon_mesh_processing::do_intersect</a> (<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> TriangleMesh &amp;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">tm1</a>, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> TriangleMesh &amp;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">tm2</a>, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">NamedParameters1</a> &amp;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">np1</a>=parameters::default_values(), <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">NamedParameters2</a> &amp;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">np2</a>=parameters::default_values())</td></tr>
<tr class="memdesc:ga362b69dbf22a03e5a852e5b2efe47e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <code>true</code> if there exists a face of <code>tm1</code> and a face of <code>tm2</code> which intersect, and <code>false</code> otherwise.  <br /></td></tr>
<tr class="separator:ga362b69dbf22a03e5a852e5b2efe47e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea4f28410f96a748e21db75c884224e3" id="r_gaea4f28410f96a748e21db75c884224e3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> TriangleMesh , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PolylineRange</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> NamedParameters  = parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:gaea4f28410f96a748e21db75c884224e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaea4f28410f96a748e21db75c884224e3">CGAL::Polygon_mesh_processing::do_intersect</a> (<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> TriangleMesh &amp;tm, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PolylineRange</a> &amp;polylines, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;np=parameters::default_values())</td></tr>
<tr class="memdesc:gaea4f28410f96a748e21db75c884224e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <code>true</code> if there exists a face of <code>tm</code> and a segment of a polyline of <code>polylines</code> which intersect, and <code>false</code> otherwise.  <br /></td></tr>
<tr class="separator:gaea4f28410f96a748e21db75c884224e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d563c139d9803ed0211f9828805d881" id="r_ga1d563c139d9803ed0211f9828805d881"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> TriangleMesh , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Polyline</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> NamedParameters  = CGAL::parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga1d563c139d9803ed0211f9828805d881"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1d563c139d9803ed0211f9828805d881">CGAL::Polygon_mesh_processing::do_intersect</a> (<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> TriangleMesh &amp;tm, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Polyline</a> &amp;polyline, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;np=parameters::default_values())</td></tr>
<tr class="memdesc:ga1d563c139d9803ed0211f9828805d881"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <code>true</code> if there exists a face of <code>tm</code> and a segment of <code>polyline</code> which intersect, and <code>false</code> otherwise.  <br /></td></tr>
<tr class="separator:ga1d563c139d9803ed0211f9828805d881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0a7348487c7bf93dced127d82afc918" id="r_gaf0a7348487c7bf93dced127d82afc918"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">TriangleMeshRange</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">OutputIterator</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> NamedParameters , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">NamedParametersRange</a> &gt; </td></tr>
<tr class="memitem:gaf0a7348487c7bf93dced127d82afc918"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">OutputIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaf0a7348487c7bf93dced127d82afc918">CGAL::Polygon_mesh_processing::intersecting_meshes</a> (<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">TriangleMeshRange</a> &amp;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">range</a>, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">OutputIterator</a> out, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;np, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">NamedParametersRange</a> &amp;nps)</td></tr>
<tr class="memdesc:gaf0a7348487c7bf93dced127d82afc918"><td class="mdescLeft">&#160;</td><td class="mdescRight">detects and reports all the pairs of meshes intersecting in a range of triangulated surface meshes.  <br /></td></tr>
<tr class="separator:gaf0a7348487c7bf93dced127d82afc918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c8f1c1aba66b32be12d88f852f87fb0" id="r_ga5c8f1c1aba66b32be12d88f852f87fb0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">ConcurrencyTag</a>  = Sequential_tag, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> TriangleMesh , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">FaceRange</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">FacePairOutputIterator</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> NamedParameters  = parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga5c8f1c1aba66b32be12d88f852f87fb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">FacePairOutputIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5c8f1c1aba66b32be12d88f852f87fb0">CGAL::Polygon_mesh_processing::self_intersections</a> (<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">FaceRange</a> &amp;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">face_range</a>, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> TriangleMesh &amp;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">tmesh</a>, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">FacePairOutputIterator</a> out, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;np=parameters::default_values())</td></tr>
<tr class="memdesc:ga5c8f1c1aba66b32be12d88f852f87fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">collects intersections between a subset of faces of a triangulated surface mesh.  <br /></td></tr>
<tr class="separator:ga5c8f1c1aba66b32be12d88f852f87fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c5bed399d14ddbba820ce50d3145712" id="r_ga6c5bed399d14ddbba820ce50d3145712"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">ConcurrencyTag</a>  = Sequential_tag, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> TriangleMesh , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">FacePairOutputIterator</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> NamedParameters  = CGAL::parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga6c5bed399d14ddbba820ce50d3145712"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">FacePairOutputIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga6c5bed399d14ddbba820ce50d3145712">CGAL::Polygon_mesh_processing::self_intersections</a> (<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> TriangleMesh &amp;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">tmesh</a>, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">FacePairOutputIterator</a> out, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;np=parameters::default_values())</td></tr>
<tr class="memdesc:ga6c5bed399d14ddbba820ce50d3145712"><td class="mdescLeft">&#160;</td><td class="mdescRight">collects intersections between all the faces of a triangulated surface mesh.  <br /></td></tr>
<tr class="separator:ga6c5bed399d14ddbba820ce50d3145712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10428990783d0fc500bb1be8e5d10a42" id="r_ga10428990783d0fc500bb1be8e5d10a42"><td class="memTemplParams" colspan="2">template&lt;class ConcurrencyTag  = Sequential_tag, class FaceRange , class TriangleMesh , class NamedParameters  = parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga10428990783d0fc500bb1be8e5d10a42"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">CGAL::Polygon_mesh_processing::does_self_intersect</a> (const FaceRange &amp;face_range, const TriangleMesh &amp;tmesh, const NamedParameters &amp;np=parameters::default_values())</td></tr>
<tr class="memdesc:ga10428990783d0fc500bb1be8e5d10a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if a set of faces of a triangulated surface mesh self-intersects.  <br /></td></tr>
<tr class="separator:ga10428990783d0fc500bb1be8e5d10a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28affb9bdf1b38765479609084cd1e94" id="r_ga28affb9bdf1b38765479609084cd1e94"><td class="memTemplParams" colspan="2">template&lt;class ConcurrencyTag  = Sequential_tag, class TriangleMesh , class NamedParameters  = CGAL::parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga28affb9bdf1b38765479609084cd1e94"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga28affb9bdf1b38765479609084cd1e94">CGAL::Polygon_mesh_processing::does_self_intersect</a> (const TriangleMesh &amp;tmesh, const NamedParameters &amp;np=parameters::default_values())</td></tr>
<tr class="memdesc:ga28affb9bdf1b38765479609084cd1e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if a triangulated surface mesh self-intersects.  <br /></td></tr>
<tr class="separator:ga28affb9bdf1b38765479609084cd1e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c5fee17bd0d92d5a2fba77ed94d4b4d" id="r_ga1c5fee17bd0d92d5a2fba77ed94d4b4d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">ConcurrencyTag</a>  = Sequential_tag, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">TriangleRange</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">TriangleIdPairOutputIterator</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> NamedParameters  = CGAL::parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga1c5fee17bd0d92d5a2fba77ed94d4b4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">TriangleIdPairOutputIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1c5fee17bd0d92d5a2fba77ed94d4b4d">CGAL::Polygon_mesh_processing::triangle_soup_self_intersections</a> (<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> &amp;points, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">TriangleRange</a> &amp;triangles, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">TriangleIdPairOutputIterator</a> out, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;np=parameters::default_values())</td></tr>
<tr class="memdesc:ga1c5fee17bd0d92d5a2fba77ed94d4b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">collects intersections between all the triangles in a triangle soup.  <br /></td></tr>
<tr class="separator:ga1c5fee17bd0d92d5a2fba77ed94d4b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4909920dc48b8285e69feb845feb1e53" id="r_ga4909920dc48b8285e69feb845feb1e53"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">ConcurrencyTag</a>  = Sequential_tag, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">TriangleRange</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> NamedParameters  = CGAL::parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga4909920dc48b8285e69feb845feb1e53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga4909920dc48b8285e69feb845feb1e53">CGAL::Polygon_mesh_processing::does_triangle_soup_self_intersect</a> (<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> &amp;points, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">TriangleRange</a> &amp;triangles, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;np=parameters::default_values())</td></tr>
<tr class="memdesc:ga4909920dc48b8285e69feb845feb1e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if a triangle soup self-intersects.  <br /></td></tr>
<tr class="separator:ga4909920dc48b8285e69feb845feb1e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga202575b5d28a41b7246e60e1be95a1ae" name="ga202575b5d28a41b7246e60e1be95a1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga202575b5d28a41b7246e60e1be95a1ae">&#9670;&#160;</a></span>do_intersect() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Polyline</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">bool</a> CGAL::Polygon_mesh_processing::do_intersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Polyline</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>polyline1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Polyline</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>polyline2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/intersection.h&gt;</code></p>

<p>returns <code>true</code> if there exists a segment of <code>polyline1</code> and a segment of <code>polyline2</code> which intersect, and <code>false</code> otherwise. </p>
<p>This function depends on the package <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PkgBoxIntersectionD</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Polyline</td><td>a <code>RandomAccessRange</code> of points. The point type must be from a 3D point type from CGAL Kernel. A polyline is defined as a sequence of points, each pair of contiguous points defines a segment of the polyline. If the first and last points of the polyline are identical, the polyline is closed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polyline1</td><td>the first polyline to check for intersections. </td></tr>
    <tr><td class="paramname">polyline2</td><td>the second polyline to check for intersections. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2cb4019111658999234b3e377e3eabcd" name="ga2cb4019111658999234b3e377e3eabcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cb4019111658999234b3e377e3eabcd">&#9670;&#160;</a></span>do_intersect() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PolylineRange</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">bool</a> CGAL::Polygon_mesh_processing::do_intersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PolylineRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>polylines1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PolylineRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>polylines2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/intersection.h&gt;</code></p>

<p>returns <code>true</code> if there exists a segment of a polyline of <code>polylines1</code> and a segment of a polyline of <code>polylines2</code> which intersect, and <code>false</code> otherwise. </p>
<p>This function depends on the package <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PkgBoxIntersectionD</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PolylineRange</td><td>a <code>RandomAccessRange</code> of <code>RandomAccessRange</code> of points. The point type must be from a 3D point from a CGAL Kernel. A polyline is defined as a sequence of points, each pair of contiguous points defines a segment of the polyline. If the first and last points of the polyline are identical, the polyline is closed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polylines1</td><td>the first range of polylines to check for intersections. </td></tr>
    <tr><td class="paramname">polylines2</td><td>the second range of polylines to check for intersections. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1d563c139d9803ed0211f9828805d881" name="ga1d563c139d9803ed0211f9828805d881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d563c139d9803ed0211f9828805d881">&#9670;&#160;</a></span>do_intersect() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> TriangleMesh , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Polyline</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> NamedParameters  = CGAL::parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">bool</a> CGAL::Polygon_mesh_processing::do_intersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> TriangleMesh &amp;</td>          <td class="paramname"><span class="paramname"><em>tm</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Polyline</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>polyline</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>np</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/intersection.h&gt;</code></p>

<p>returns <code>true</code> if there exists a face of <code>tm</code> and a segment of <code>polyline</code> which intersect, and <code>false</code> otherwise. </p>
<p>This function depends on the package <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PkgBoxIntersectionD</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>CGAL::is_triangle_mesh(tm)</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code>FaceListGraph</code> </td></tr>
    <tr><td class="paramname">Polyline</td><td>a <code>RandomAccessRange</code> of points. The point type of the range must be the same as the value type of the vertex point map. A polyline is defined as a sequence of points, each pair of contiguous points defines a segment of the polyline. If the first and last points of the polyline are identical, the polyline is closed. </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tm</td><td>the triangulated surface mesh to check for intersections </td></tr>
    <tr><td class="paramname">polyline</td><td>the polyline to check for intersections. </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>tm</code> </li>
<li>
<b>Type: </b>a class model of <code>ReadWritePropertyMap</code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, tm)</code> </li>
<li>
<b>Extra: </b>If this parameter is omitted, an internal property map for <code>CGAL::vertex_point_t</code> should be available for the vertices of <code>tm</code>. </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>a class model of <code><a class="el" href="classPMPSelfIntersectionTraits.html" title="Geometric traits concept for the functions CGAL::self_intersections() and CGAL::does_self_intersect()...">PMPSelfIntersectionTraits</a></code> </li>
<li>
<b>Default: </b>a CGAL Kernel deduced from the point type, using <code>CGAL::Kernel_traits</code> </li>
<li>
<b>Extra: </b>The geometric traits class must be compatible with the vertex point type. </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a id="gaea4f28410f96a748e21db75c884224e3" name="gaea4f28410f96a748e21db75c884224e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea4f28410f96a748e21db75c884224e3">&#9670;&#160;</a></span>do_intersect() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> TriangleMesh , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PolylineRange</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> NamedParameters  = parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">bool</a> CGAL::Polygon_mesh_processing::do_intersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> TriangleMesh &amp;</td>          <td class="paramname"><span class="paramname"><em>tm</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PolylineRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>polylines</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>np</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/intersection.h&gt;</code></p>

<p>returns <code>true</code> if there exists a face of <code>tm</code> and a segment of a polyline of <code>polylines</code> which intersect, and <code>false</code> otherwise. </p>
<p>This function depends on the package <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PkgBoxIntersectionD</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>CGAL::is_triangle_mesh(tm)</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code>FaceListGraph</code> </td></tr>
    <tr><td class="paramname">PolylineRange</td><td>a <code>RandomAccessRange</code> of <code>RandomAccessRange</code> of points. The point type of the range must be the same as the value type of the vertex point map. A polyline is defined as a sequence of points, each pair of contiguous points defines a segment of the polyline. If the first and last points of the polyline are identical, the polyline is closed. </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">bgl_namedparameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tm</td><td>the triangulated surface mesh to check for intersections </td></tr>
    <tr><td class="paramname">polylines</td><td>the range of polylines to check for intersections. </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>tm</code> </li>
<li>
<b>Type: </b>a class model of <code>ReadWritePropertyMap</code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, tm)</code> </li>
<li>
<b>Extra: </b>If this parameter is omitted, an internal property map for <code>CGAL::vertex_point_t</code> should be available for the vertices of <code>tm</code>. </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>a class model of <code><a class="el" href="classPMPSelfIntersectionTraits.html" title="Geometric traits concept for the functions CGAL::self_intersections() and CGAL::does_self_intersect()...">PMPSelfIntersectionTraits</a></code> </li>
<li>
<b>Default: </b>a CGAL Kernel deduced from the point type, using <code>CGAL::Kernel_traits</code> </li>
<li>
<b>Extra: </b>The geometric traits class must be compatible with the vertex point type. </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a id="ga362b69dbf22a03e5a852e5b2efe47e12" name="ga362b69dbf22a03e5a852e5b2efe47e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga362b69dbf22a03e5a852e5b2efe47e12">&#9670;&#160;</a></span>do_intersect() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> TriangleMesh , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">NamedParameters1</a>  = CGAL::parameters::Default_named_parameter, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">NamedParameters2</a>  = CGAL::parameters::Default_named_parameter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">bool</a> CGAL::Polygon_mesh_processing::do_intersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> TriangleMesh &amp;</td>          <td class="paramname"><span class="paramname"><em>tm1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> TriangleMesh &amp;</td>          <td class="paramname"><span class="paramname"><em>tm2</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">NamedParameters1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>np1</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">NamedParameters2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>np2</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/intersection.h&gt;</code></p>

<p>returns <code>true</code> if there exists a face of <code>tm1</code> and a face of <code>tm2</code> which intersect, and <code>false</code> otherwise. </p>
<p>If <code>do_overlap_test_of_bounded_sides</code> is set to <code>true</code>, the overlap of bounded sides are tested as well. In that case, the meshes must be closed. This function depends on the package <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PkgBoxIntersectionD</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>CGAL::is_triangle_mesh(tm1)</code> </dd>
<dd>
<code>CGAL::is_triangle_mesh(tm2)</code> </dd>
<dd>
<code>!do_overlap_test_of_bounded_sides || CGAL::is_closed(tm1)</code> </dd>
<dd>
<code>!do_overlap_test_of_bounded_sides || CGAL::is_closed(tm2)</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code>FaceListGraph</code> </td></tr>
    <tr><td class="paramname">NamedParameters1</td><td>a sequence of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> for <code>tm1</code> </td></tr>
    <tr><td class="paramname">NamedParameters2</td><td>a sequence of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> for <code>tm2</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tm1</td><td>the first triangulated surface mesh to check for intersections </td></tr>
    <tr><td class="paramname">tm2</td><td>the second triangulated surface mesh to check for intersections </td></tr>
    <tr><td class="paramname">np1</td><td>an optional sequence of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below </td></tr>
    <tr><td class="paramname">np2</td><td>an optional sequence of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>tm1</code> (<code>tm2</code>) </li>
<li>
<b>Type: </b>a class model of <code>ReadablePropertyMap</code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, tm1 (tm2))</code> </li>
<li>
<b>Extra: </b>If this parameter is omitted, an internal property map for <code>CGAL::vertex_point_t</code> should be available for the vertices of <code>tm1</code> (<code>tm2</code>) </li>
<li>
<b>Extra: </b>Both vertex point maps must have the same value type </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>a class model of <code><a class="el" href="classPMPSelfIntersectionTraits.html" title="Geometric traits concept for the functions CGAL::self_intersections() and CGAL::does_self_intersect()...">PMPSelfIntersectionTraits</a></code> </li>
<li>
<b>Default: </b>a CGAL Kernel deduced from the point type, using <code>CGAL::Kernel_traits</code> </li>
<li>
<b>Extra: </b>The geometric traits class must be compatible with the vertex point type. </li>
<li>
<b>Extra: </b>np1 only </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>do_overlap_test_of_bounded_sides</b> </button> <div class="content"><ul>
<li>
If <code>true</code>, also tests the overlap of the bounded sides of <code>tm1</code> and <code>tm2</code>. If <code>false</code>, only the intersection of surface triangles is tested. </li>
<li>
<b>Type: </b>Boolean </li>
<li>
<b>Default: </b><code>false</code> </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#gaf0a7348487c7bf93dced127d82afc918" title="detects and reports all the pairs of meshes intersecting in a range of triangulated surface meshes.">intersecting_meshes()</a></code> </dd></dl>

</div>
</div>
<a id="ga10428990783d0fc500bb1be8e5d10a42" name="ga10428990783d0fc500bb1be8e5d10a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10428990783d0fc500bb1be8e5d10a42">&#9670;&#160;</a></span>does_self_intersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ConcurrencyTag  = Sequential_tag, class FaceRange , class TriangleMesh , class NamedParameters  = parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGAL::Polygon_mesh_processing::does_self_intersect </td>
          <td>(</td>
          <td class="paramtype">const FaceRange &amp;</td>          <td class="paramname"><span class="paramname"><em>face_range</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp;</td>          <td class="paramname"><span class="paramname"><em>tmesh</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>np</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/self_intersections.h&gt;</code></p>

<p>tests if a set of faces of a triangulated surface mesh self-intersects. </p>
<p>This function depends on the package <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PkgBoxIntersectionD</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>CGAL::is_triangle_mesh(tmesh)</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ConcurrencyTag</td><td>enables sequential versus parallel algorithm. Possible values are <code>Sequential_tag</code>, <code>Parallel_tag</code>, and <code>Parallel_if_available_tag</code>. </td></tr>
    <tr><td class="paramname">FaceRange</td><td>a range of <code>face_descriptor</code> </td></tr>
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code>FaceListGraph</code> </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face_range</td><td>the set of faces to test for self-intersection </td></tr>
    <tr><td class="paramname">tmesh</td><td>the triangulated surface mesh to be tested </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>tmesh</code> </li>
<li>
<b>Type: </b>a class model of <code>ReadWritePropertyMap</code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, tmesh)</code> </li>
<li>
<b>Extra: </b>If this parameter is omitted, an internal property map for <code>CGAL::vertex_point_t</code> should be available for the vertices of <code>tmesh</code>. </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>a class model of <code><a class="el" href="classPMPSelfIntersectionTraits.html" title="Geometric traits concept for the functions CGAL::self_intersections() and CGAL::does_self_intersect()...">PMPSelfIntersectionTraits</a></code> </li>
<li>
<b>Default: </b>a CGAL Kernel deduced from the point type, using <code>CGAL::Kernel_traits</code> </li>
<li>
<b>Extra: </b>The geometric traits class must be compatible with the vertex point type. </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the faces in <code>face_range</code> self-intersect</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ga5c8f1c1aba66b32be12d88f852f87fb0" title="collects intersections between a subset of faces of a triangulated surface mesh.">self_intersections()</a></code> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Polygon_mesh_processing_2triangulate_faces_split_visitor_example_8cpp-example.html#a1">Polygon_mesh_processing/triangulate_faces_split_visitor_example.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga28affb9bdf1b38765479609084cd1e94" name="ga28affb9bdf1b38765479609084cd1e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28affb9bdf1b38765479609084cd1e94">&#9670;&#160;</a></span>does_self_intersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ConcurrencyTag  = Sequential_tag, class TriangleMesh , class NamedParameters  = CGAL::parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGAL::Polygon_mesh_processing::does_self_intersect </td>
          <td>(</td>
          <td class="paramtype">const TriangleMesh &amp;</td>          <td class="paramname"><span class="paramname"><em>tmesh</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>np</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/self_intersections.h&gt;</code></p>

<p>tests if a triangulated surface mesh self-intersects. </p>
<p>This function depends on the package <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PkgBoxIntersectionD</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>CGAL::is_triangle_mesh(tmesh)</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ConcurrencyTag</td><td>enables sequential versus parallel algorithm. Possible values are <code>Sequential_tag</code>, <code>Parallel_tag</code>, and <code>Parallel_if_available_tag</code>. </td></tr>
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code>FaceListGraph</code> </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmesh</td><td>the triangulated surface mesh to be tested </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>tmesh</code> </li>
<li>
<b>Type: </b>a class model of <code>ReadWritePropertyMap</code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, tmesh)</code> </li>
<li>
<b>Extra: </b>If this parameter is omitted, an internal property map for <code>CGAL::vertex_point_t</code> should be available for the vertices of <code>tmesh</code>. </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>a class model of <code><a class="el" href="classPMPSelfIntersectionTraits.html" title="Geometric traits concept for the functions CGAL::self_intersections() and CGAL::does_self_intersect()...">PMPSelfIntersectionTraits</a></code> </li>
<li>
<b>Default: </b>a CGAL Kernel deduced from the point type, using <code>CGAL::Kernel_traits</code> </li>
<li>
<b>Extra: </b>The geometric traits class must be compatible with the vertex point type. </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>tmesh</code> self-intersects</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ga5c8f1c1aba66b32be12d88f852f87fb0" title="collects intersections between a subset of faces of a triangulated surface mesh.">self_intersections()</a></code> </dd></dl>

</div>
</div>
<a id="ga4909920dc48b8285e69feb845feb1e53" name="ga4909920dc48b8285e69feb845feb1e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4909920dc48b8285e69feb845feb1e53">&#9670;&#160;</a></span>does_triangle_soup_self_intersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">ConcurrencyTag</a>  = Sequential_tag, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">TriangleRange</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> NamedParameters  = CGAL::parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">bool</a> CGAL::Polygon_mesh_processing::does_triangle_soup_self_intersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">TriangleRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>triangles</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>np</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/self_intersections.h&gt;</code></p>

<p>tests if a triangle soup self-intersects. </p>
<p>A triangle soup self-intersects if at least two triangles of the soup intersect. Two triangles of the soup are said to intersect if the corresponding geometric triangles intersect and the intersection is neither an edge nor a vertex of both triangles (with the same point ids, ignoring the orientation for an edge).</p>
<p>This function depends on the package <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PkgBoxIntersectionD</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ConcurrencyTag</td><td>enables sequential versus parallel algorithm. Possible values are <code>Sequential_tag</code>, <code>Parallel_tag</code>, and <code>Parallel_if_available_tag</code>. </td></tr>
    <tr><td class="paramname">PointRange</td><td>a model of the concept <code>RandomAccessContainer</code> whose value type is the point type </td></tr>
    <tr><td class="paramname">TriangleRange</td><td>a model of the concept <code>RandomAccessContainer</code> whose value type is a model of the concept <code>RandomAccessContainer</code> whose value type is <code>std::size_t</code> </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>points of the soup of triangles </td></tr>
    <tr><td class="paramname">triangles</td><td>each element in the range describes a triangle using the indices of the points in <code>points</code> </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the elements of the range <code>points</code> </li>
<li>
<b>Type: </b>a model of <code>ReadablePropertyMap</code> whose value type is a point type from a CGAL <code>Kernel</code>. </li>
<li>
<b>Default: </b><code>CGAL::Identity_property_map</code> </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>a class model of <code><a class="el" href="classPMPSelfIntersectionTraits.html" title="Geometric traits concept for the functions CGAL::self_intersections() and CGAL::does_self_intersect()...">PMPSelfIntersectionTraits</a></code> </li>
<li>
<b>Default: </b>a CGAL Kernel deduced from the point type, using <code>CGAL::Kernel_traits</code> </li>
<li>
<b>Extra: </b>The geometric traits class must be compatible with the point type of the point map. </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the triangle soup self-intersects, and <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ga1c5fee17bd0d92d5a2fba77ed94d4b4d" title="collects intersections between all the triangles in a triangle soup.">triangle_soup_self_intersections()</a></code> </dd>
<dd>
<code><a class="el" href="#ga5c8f1c1aba66b32be12d88f852f87fb0" title="collects intersections between a subset of faces of a triangulated surface mesh.">self_intersections()</a></code> </dd>
<dd>
<code><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42" title="tests if a set of faces of a triangulated surface mesh self-intersects.">does_self_intersect()</a></code> </dd></dl>

</div>
</div>
<a id="gaf0a7348487c7bf93dced127d82afc918" name="gaf0a7348487c7bf93dced127d82afc918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0a7348487c7bf93dced127d82afc918">&#9670;&#160;</a></span>intersecting_meshes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">TriangleMeshRange</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">OutputIterator</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> NamedParameters , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">NamedParametersRange</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">OutputIterator</a> CGAL::Polygon_mesh_processing::intersecting_meshes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">TriangleMeshRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">OutputIterator</a></td>          <td class="paramname"><span class="paramname"><em>out</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>np</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">NamedParametersRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>nps</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/intersection.h&gt;</code></p>

<p>detects and reports all the pairs of meshes intersecting in a range of triangulated surface meshes. </p>
<p>A pair of meshes intersecting is put in the output iterator <code>out</code> as a <code>std::pair&lt;std::size_t, std::size_t&gt;</code>, each index referring to the index of the triangle mesh in the input range. If <code>do_overlap_test_of_bounded_sides</code> is <code>true</code>, the overlap of bounded sides are tested as well. In that case, the meshes must be closed. This function depends on the package <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PkgBoxIntersectionD</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMeshRange</td><td>a model of <code>RandomAccessRange</code> of triangulated surface meshes model of <code>FaceListGraph</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>an output iterator in which <code>std::pair&lt;std::size_t, std::size_t&gt;</code> can be put. </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> for the algorithm </td></tr>
    <tr><td class="paramname">NamedParametersRange</td><td>a range of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> for the meshes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>the range of triangulated surface meshes to be checked for intersections. </td></tr>
    <tr><td class="paramname">out</td><td>output iterator used to collect pairs of intersecting meshes. </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>a class model of <code><a class="el" href="classPMPSelfIntersectionTraits.html" title="Geometric traits concept for the functions CGAL::self_intersections() and CGAL::does_self_intersect()...">PMPSelfIntersectionTraits</a></code> </li>
<li>
<b>Default: </b>a CGAL Kernel deduced from the point type, using <code>CGAL::Kernel_traits</code>, where <code>Point</code> is the value type of the vertex point map of the meshes </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>do_overlap_test_of_bounded_sides</b> </button> <div class="content"><ul>
<li>
If <code>true</code>, reports also overlap of bounded sides of meshes. If <code>false</code>, only the intersection of surface triangles are tested. </li>
<li>
<b>Type: </b>Boolean </li>
<li>
<b>Default: </b><code>false</code> </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nps</td><td>an optional range of sequences of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of a mesh <code>tm</code> </li>
<li>
<b>Type: </b>a class model of <code>ReadablePropertyMap</code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, tm)</code> </li>
<li>
<b>Extra: </b>If this parameter is omitted, an internal property map for <code>CGAL::vertex_point_t</code> should be available for the vertices of <code>tm</code>. </li>
<li>
<b>Extra: </b>All vertex point maps must have the same value type </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ga2cb4019111658999234b3e377e3eabcd" title="returns true if there exists a segment of a polyline of polylines1 and a segment of a polyline of pol...">do_intersect()</a></code> </dd></dl>

</div>
</div>
<a id="ga5c8f1c1aba66b32be12d88f852f87fb0" name="ga5c8f1c1aba66b32be12d88f852f87fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c8f1c1aba66b32be12d88f852f87fb0">&#9670;&#160;</a></span>self_intersections() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">ConcurrencyTag</a>  = Sequential_tag, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> TriangleMesh , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">FaceRange</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">FacePairOutputIterator</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> NamedParameters  = parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">FacePairOutputIterator</a> CGAL::Polygon_mesh_processing::self_intersections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">FaceRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>face_range</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> TriangleMesh &amp;</td>          <td class="paramname"><span class="paramname"><em>tmesh</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">FacePairOutputIterator</a></td>          <td class="paramname"><span class="paramname"><em>out</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>np</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/self_intersections.h&gt;</code></p>

<p>collects intersections between a subset of faces of a triangulated surface mesh. </p>
<p>Two faces are said to intersect if the corresponding triangles intersect and the intersection is neither an edge nor a vertex incident to both faces.</p>
<p>This function depends on the package <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PkgBoxIntersectionD</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>CGAL::is_triangle_mesh(tmesh)</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ConcurrencyTag</td><td>enables sequential versus parallel algorithm. Possible values are <code>Sequential_tag</code>, <code>Parallel_tag</code>, and <code>Parallel_if_available_tag</code>. </td></tr>
    <tr><td class="paramname">FaceRange</td><td>a model of <code>ConstRange</code> with value type <code>boost::graph_traits&lt;TriangleMesh&gt;::face_descriptor</code>. </td></tr>
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code>FaceListGraph</code> </td></tr>
    <tr><td class="paramname">FacePairOutputIterator</td><td>a model of <code>OutputIterator</code> holding objects of type <code>std::pair&lt;boost::graph_traits&lt;TriangleMesh&gt;::face_descriptor, boost::graph_traits&lt;TriangleMesh&gt;::face_descriptor&gt;</code>. It does not need to be thread-safe. </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face_range</td><td>the range of faces to check for self-intersection. </td></tr>
    <tr><td class="paramname">tmesh</td><td>the triangulated surface mesh to be checked </td></tr>
    <tr><td class="paramname">out</td><td>output iterator to be filled with all pairs of non-adjacent faces that intersect </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>tmesh</code> </li>
<li>
<b>Type: </b>a class model of <code>ReadWritePropertyMap</code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, tmesh)</code> </li>
<li>
<b>Extra: </b>If this parameter is omitted, an internal property map for <code>CGAL::vertex_point_t</code> should be available for the vertices of <code>tmesh</code>. </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>a class model of <code><a class="el" href="classPMPSelfIntersectionTraits.html" title="Geometric traits concept for the functions CGAL::self_intersections() and CGAL::does_self_intersect()...">PMPSelfIntersectionTraits</a></code> </li>
<li>
<b>Default: </b>a CGAL Kernel deduced from the point type, using <code>CGAL::Kernel_traits</code> </li>
<li>
<b>Extra: </b>The geometric traits class must be compatible with the vertex point type. </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>maximum_number</b> </button> <div class="content"><ul>
<li>
the maximum number of self intersections that will be detected and returned by the function. </li>
<li>
<b>Type: </b>unsigned int </li>
<li>
<b>Default: </b>No limit. </li>
<li>
<b>Extra: </b>In parallel mode, the number of returned self-intersections is at least <code>maximum_number</code> (and not exactly that number) as no strong synchronization is put on threads for performance reasons. </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>out</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42" title="tests if a set of faces of a triangulated surface mesh self-intersects.">does_self_intersect()</a></code> </dd></dl>

</div>
</div>
<a id="ga6c5bed399d14ddbba820ce50d3145712" name="ga6c5bed399d14ddbba820ce50d3145712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c5bed399d14ddbba820ce50d3145712">&#9670;&#160;</a></span>self_intersections() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">ConcurrencyTag</a>  = Sequential_tag, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> TriangleMesh , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">FacePairOutputIterator</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> NamedParameters  = CGAL::parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">FacePairOutputIterator</a> CGAL::Polygon_mesh_processing::self_intersections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> TriangleMesh &amp;</td>          <td class="paramname"><span class="paramname"><em>tmesh</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">FacePairOutputIterator</a></td>          <td class="paramname"><span class="paramname"><em>out</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>np</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/self_intersections.h&gt;</code></p>

<p>collects intersections between all the faces of a triangulated surface mesh. </p>
<p>Two faces are said to intersect if the corresponding triangles intersect and the intersection is neither an edge nor a vertex incident to both faces.</p>
<p>This function depends on the package <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PkgBoxIntersectionD</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>CGAL::is_triangle_mesh(tmesh)</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ConcurrencyTag</td><td>enables sequential versus parallel algorithm. Possible values are <code>Sequential_tag</code>, <code>Parallel_tag</code>, and <code>Parallel_if_available_tag</code>. </td></tr>
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code>FaceListGraph</code> </td></tr>
    <tr><td class="paramname">FacePairOutputIterator</td><td>a model of <code>OutputIterator</code> holding objects of type <code>std::pair&lt;boost::graph_traits&lt;TriangleMesh&gt;::face_descriptor, boost::graph_traits&lt;TriangleMesh&gt;::face_descriptor&gt;</code>. It does not need to be thread-safe. </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmesh</td><td>the triangulated surface mesh to be checked </td></tr>
    <tr><td class="paramname">out</td><td>output iterator to be filled with all pairs of non-adjacent faces that intersect. In case <code>tmesh</code> contains some degenerate faces, for each degenerate face <code>f</code> a pair <code>(f,f)</code> will be put in <code>out</code> before any other self intersection between non-degenerate faces. <br  />
 Note that these are the only pairs where degenerate faces will be reported. </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>tmesh</code> </li>
<li>
<b>Type: </b>a class model of <code>ReadWritePropertyMap</code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, tmesh)</code> </li>
<li>
<b>Extra: </b>If this parameter is omitted, an internal property map for <code>CGAL::vertex_point_t</code> should be available for the vertices of <code>tmesh</code>. </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>a class model of <code><a class="el" href="classPMPSelfIntersectionTraits.html" title="Geometric traits concept for the functions CGAL::self_intersections() and CGAL::does_self_intersect()...">PMPSelfIntersectionTraits</a></code> </li>
<li>
<b>Default: </b>a CGAL Kernel deduced from the point type, using <code>CGAL::Kernel_traits</code> </li>
<li>
<b>Extra: </b>The geometric traits class must be compatible with the vertex point type. </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>maximum_number</b> </button> <div class="content"><ul>
<li>
the maximum number of self intersections that will be detected and returned by the function. </li>
<li>
<b>Type: </b>unsigned int </li>
<li>
<b>Default: </b>No limit. </li>
<li>
<b>Extra: </b>In parallel mode, the number of returned self-intersections is at least <code>maximum_number</code> (and not exactly that number) as no strong synchronization is put on threads for performance reasons. </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>out</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42" title="tests if a set of faces of a triangulated surface mesh self-intersects.">does_self_intersect()</a></code> </dd></dl>

</div>
</div>
<a id="ga1c5fee17bd0d92d5a2fba77ed94d4b4d" name="ga1c5fee17bd0d92d5a2fba77ed94d4b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c5fee17bd0d92d5a2fba77ed94d4b4d">&#9670;&#160;</a></span>triangle_soup_self_intersections()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">ConcurrencyTag</a>  = Sequential_tag, <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">TriangleRange</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">TriangleIdPairOutputIterator</a> , <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">class</a> NamedParameters  = CGAL::parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">TriangleIdPairOutputIterator</a> CGAL::Polygon_mesh_processing::triangle_soup_self_intersections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">TriangleRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>triangles</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">TriangleIdPairOutputIterator</a></td>          <td class="paramname"><span class="paramname"><em>out</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">const</a> NamedParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>np</em><span class="paramdefsep"> = </span><span class="paramdefval">parameters::default_values()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/self_intersections.h&gt;</code></p>

<p>collects intersections between all the triangles in a triangle soup. </p>
<p>Two triangles of the soup are said to intersect if the corresponding geometric triangles intersect and the intersection is neither an edge nor a vertex of both triangles (with the same point ids, ignoring the orientation for an edge).</p>
<p>This function depends on the package <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">PkgBoxIntersectionD</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ConcurrencyTag</td><td>enables sequential versus parallel algorithm. Possible values are <code>Sequential_tag</code>, <code>Parallel_tag</code>, and <code>Parallel_if_available_tag</code>. </td></tr>
    <tr><td class="paramname">PointRange</td><td>a model of the concept <code>RandomAccessContainer</code> whose value type is the point type </td></tr>
    <tr><td class="paramname">TriangleRange</td><td>a model of the concept <code>RandomAccessContainer</code> whose value type is a model of the concept <code>RandomAccessContainer</code> whose value type is <code>std::size_t</code> </td></tr>
    <tr><td class="paramname">TriangleIdPairOutputIterator</td><td>a model of <code>OutputIterator</code> holding objects of type <code>std::pair&lt;std::size_t,std::size_t&gt;</code> </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>points of the soup of triangles </td></tr>
    <tr><td class="paramname">triangles</td><td>each element in the range describes a triangle using the indices of the points in <code>points</code> </td></tr>
    <tr><td class="paramname">out</td><td>output iterator to be filled with all pairs of ids of triangles intersecting (the id of a triangle is its position in <code>triangles</code>). In case the triangle soup contains some degenerate triangles, for each degenerate triangle <code>t</code> with id <code>i</code> a pair <code>(i,i)</code> will be put in <code>out</code> before any other self intersection between non-degenerate triangles.<br  />
 Note that these are the only pairs where degenerate triangles will be reported. </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>maximum_number</b> </button> <div class="content"><ul>
<li>
the maximum number of self intersections that will be detected and returned by the function. </li>
<li>
<b>Type: </b>unsigned int </li>
<li>
<b>Default: </b>No limit. </li>
<li>
<b>Extra: </b>In parallel mode, the number of returned self-intersections is at least <code>maximum_number</code> (and not exactly that number) as no strong synchronization is put on threads for performance reasons. </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the elements of the range <code>points</code> </li>
<li>
<b>Type: </b>a model of <code>ReadablePropertyMap</code> whose value type is a point type from a CGAL <code>Kernel</code>. </li>
<li>
<b>Default: </b><code>CGAL::Identity_property_map</code> </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>a class model of <code><a class="el" href="classPMPSelfIntersectionTraits.html" title="Geometric traits concept for the functions CGAL::self_intersections() and CGAL::does_self_intersect()...">PMPSelfIntersectionTraits</a></code> </li>
<li>
<b>Default: </b>a CGAL Kernel deduced from the point type, using <code>CGAL::Kernel_traits</code> </li>
<li>
<b>Extra: </b>The geometric traits class must be compatible with the point type of the point map. </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>out</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ga4909920dc48b8285e69feb845feb1e53" title="tests if a triangle soup self-intersects.">does_triangle_soup_self_intersect()</a></code> </dd>
<dd>
<code><a class="el" href="#ga5c8f1c1aba66b32be12d88f852f87fb0" title="collects intersections between a subset of faces of a triangulated surface mesh.">self_intersections()</a></code> </dd>
<dd>
<code><a class="el" href="#ga10428990783d0fc500bb1be8e5d10a42" title="tests if a set of faces of a triangulated surface mesh self-intersects.">does_self_intersect()</a></code> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</div>
</body>
</html>
