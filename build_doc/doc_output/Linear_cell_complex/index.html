<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CGAL 6.0 - Linear Cell Complex: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script src="../Manual/cookie.js" type="text/javascript"></script>
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="topics.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()">&#160;
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)"
               onblur="searchBox.OnSearchFieldFocus(false)"
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""/></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.0 - Linear Cell Complex
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">User Manual </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Linear_Cell_Complex"></a><a class="anchor" id="ChapterLinearCellComplex"></a> </p><dl class="section author"><dt>Author</dt><dd>Guillaume Damiand  <div id="autotoc" class="toc"></div> </dd></dl>
<h1><a class="anchor" id="Linear_cell_complexIntroduction"></a>
Introduction</h1>
<p>A <em>d</em>D linear cell complex allows to represent an orientable subdivided <em>d</em>D object having linear geometry: each vertex of the subdivision is associated with a point. The geometry of each edge is a segment whose end points are associated with the two vertices of the edge, the geometry of each 2-cell is obtained from all the segments associated to the edges describing the boundary of the 2-cell and so on.</p>
<p>The combinatorial part of a linear cell complex is described either by a <em>d</em>D combinatorial map or by a <em>d</em>D generalized map (it is strongly recommended to first read the Combinatorial maps user manual or Generalized maps user manual for definitions). To add the linear geometrical embedding, a point (a model of <a class="el" href=""><code>Point_2</code></a> or <a class="el" href=""><code>Point_3</code></a> or <a class="el" href=""><code>Point_d</code></a>) is associated to each vertex of the combinatorial data-structure.</p>
<p><a class="anchor" id="fig__fig_lcc_example_subdivisions"></a> </p><div class="image">
<object type="image/svg+xml" data="lcc_example_subdivisions.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="#fig__fig_lcc_example_subdivisions">fig__fig_lcc_example_subdivisions</a> Examples of objects with linear geometry. <b>Left</b>: A 2D object composed of three 2-cells, nine 1-cells and seven points associated to the seven 0-cells . <b>Right</b>: A 3D object composed of three 3-cells, twelve 2-cells, sixteen 1-cells and eight points associated to the eight 0-cells. </p> </div> <p> <br  />
</p>
<p>If we reconsider the example introduced in the combinatorial map package, recalled in <a class="el" href="#fig__fig_lcc_example_subdivisions">fig__fig_lcc_example_subdivisions</a> (Right), the combinatorial part of the 3D object is described by a 3D combinatorial map. As illustrated in <a class="el" href="#fig__fig_lcc_examples_zoom">fig__fig_lcc_examples_zoom</a>, the geometrical part of the object is described by associating a point to each vertex of the map.</p>
<p><a class="anchor" id="fig__fig_lcc_examples_zoom"></a> </p><div class="image">
<object type="image/svg+xml" data="lcc_examples_zoom.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="#fig__fig_lcc_examples_zoom">fig__fig_lcc_examples_zoom</a> Example of 3D linear cell complex describing the object given in <a class="el" href="#fig__fig_lcc_example_subdivisions">fig__fig_lcc_example_subdivisions</a> (Right). <b>Left</b>: The 3D linear cell complex which contains 54 darts (18 for each 3-cell) where each vertex is associated with a point, here a <code>Point_3</code>. Blue segments represent \( \beta_3\) relations. <b>Middle</b>: Zoom around the central edge which details the six darts belonging to the edge and the associations between darts and points. <b>Right</b>: Zoom around the facet between light gray and white 3-cells, which details the eight darts belonging to the facet and the associations between darts and points (given by red segments). </p> </div> <p> <br  />
</p>
<p>Things are similar for generalized map, as illustrated in <a class="el" href="#fig__fig_lcc_example_gmap">fig__fig_lcc_example_gmap</a>. In this example, a 2D generalized map is used as underlying data-structure to describe the object given in <a class="el" href="#fig__fig_lcc_example_subdivisions">fig__fig_lcc_example_subdivisions</a> (Left). The 2D linear cell complex shown in <a class="el" href="#fig__fig_lcc_example_gmap">fig__fig_lcc_example_gmap</a> (Left) is obtained from this 2D generalized map by associating a point to each vertex of the map. We can compare in <a class="el" href="#fig__fig_lcc_example_subdivisions">fig__fig_lcc_example_subdivisions</a> (Right) this 2D linear cell complex with the 2D linear cell complex describing the same 2D object but using 2D combinatorial maps (instead of generalized map). The only difference comes from the original definitions of combinatorial and generalized maps. Combinatorial maps have twice less darts than generalized maps, and thus the corresponding 2D linear cell complex has twice less association between darts and points.</p>
<p><a class="anchor" id="fig__fig_lcc_example_gmap"></a> </p><div class="image">
<object type="image/svg+xml" data="lcc_example_gmap.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="#fig__fig_lcc_example_gmap">fig__fig_lcc_example_gmap</a> Example of 2D linear cell complexes describing the object given in <a class="el" href="#fig__fig_lcc_example_subdivisions">fig__fig_lcc_example_subdivisions</a> (Left). (Left) Based on a 2D generalized map. (Right) Based on a 2D combinatorial map. In both cases, each vertex of the combinatorial data-structure is associated with a point, here a <code>Point_2</code>. Associations between darts and points is drawn by red segments. </p> </div> <p> <br  />
</p>
<p>Note that the dimension of the combinatorial or the generalized map <em>d</em> is not necessarily equal to the dimension of the ambient space <em>d2</em>. Indeed, we can use for example a 2D combinatorial map in a 2D ambient space to describe a planar graph (<em>d</em>=<em>d2</em>=<em>2</em>), or a 2D combinatorial map in a 3D ambient space to describe a surface in 3D space (<em>d</em>=2, <em>d2</em>=3) (case of the <code>Polyhedron_3</code> package), or a 3D generalized map in a 3D ambient space (<em>d</em>=<em>d2</em>=3) and so on.</p>
<h1><a class="anchor" id="Linear_cell_complexSoftware"></a>
Software Design</h1>
<p>The diagram in <a class="el" href="#fig__fig_lcc_diagramme_class">fig__fig_lcc_diagramme_class</a> shows the main classes of the package. <code><a class="el" href="classCGAL_1_1Linear__cell__complex__for__combinatorial__map.html" title="The class Linear_cell_complex_for_combinatorial_map represents a linear cell complex in dimension d,...">Linear_cell_complex_for_combinatorial_map</a></code> is the main class if you use combinatorial maps as combinatorial data-structure, and <code><a class="el" href="classCGAL_1_1Linear__cell__complex__for__generalized__map.html" title="The class Linear_cell_complex_for_generalized_map represents a linear cell complex in dimension d,...">Linear_cell_complex_for_generalized_map</a></code> is the main class if you use generalized maps as combinatorial data-structure (see Section <a class="el" href="#sseclinearcellcomplex">Linear Cell Complex</a>). <code><a class="el" href="classCGAL_1_1Linear__cell__complex__for__combinatorial__map.html" title="The class Linear_cell_complex_for_combinatorial_map represents a linear cell complex in dimension d,...">Linear_cell_complex_for_combinatorial_map</a></code> inherits from the <code>Combinatorial_map</code> class and <code><a class="el" href="classCGAL_1_1Linear__cell__complex__for__generalized__map.html" title="The class Linear_cell_complex_for_generalized_map represents a linear cell complex in dimension d,...">Linear_cell_complex_for_generalized_map</a></code> inherits from the <code>Generalized_map</code> class. Attributes can be associated to some cells of the linear cell complex thanks to an items class (see Section <a class="el" href="#sseclccitem">Linear Cell Complex Items</a>), which defines the information associated to darts, and the attributes types. These types may be different for different dimensions of cells, and they may also be void. In the class <code><a class="el" href="classCGAL_1_1Linear__cell__complex__for__combinatorial__map.html" title="The class Linear_cell_complex_for_combinatorial_map represents a linear cell complex in dimension d,...">Linear_cell_complex_for_combinatorial_map</a></code>, it is required that specific attributes are associated to all vertices of the combinatorial or generalized map. These attributes must contain a point (a model of <a class="el" href=""><code>Point_2</code></a> or <a class="el" href=""><code>Point_3</code></a> or <a class="el" href=""><code>Point_d</code></a>), and can be represented by instances of class <code><a class="el" href="classCGAL_1_1Cell__attribute__with__point.html" title="The class Cell_attribute_with_point represents an attribute containing a point and containing an info...">Cell_attribute_with_point</a></code> (see Section <a class="el" href="#ssecattributewp">Cell Attributes</a>).</p>
<p><a class="anchor" id="fig__fig_lcc_diagramme_class"></a> </p><div class="image">
<object type="image/svg+xml" data="lcc_diagramme_class.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="#fig__fig_lcc_diagramme_class">fig__fig_lcc_diagramme_class</a> UML diagram of the main classes of the package. Gray elements come from the Combinatorial maps and Generalized maps packages. </p> </div> <p> <br  />
</p>
<h1><a class="anchor" id="sseclinearcellcomplex"></a>
Linear Cell Complex</h1>
<p>The <a class="el" href="classCGAL_1_1Linear__cell__complex__for__combinatorial__map.html"><code>Linear_cell_complex_for_combinatorial_map&lt;d,d2,LCCTraits,Items,Alloc&gt;</code></a> class is a model of the <code><a class="el" href="classLinearCellComplex.html" title="The concept LinearCellComplex represents a linear cell complex in dimension d, in an ambient space of...">LinearCellComplex</a></code> concept that uses a combinatorial map as underlying combinatorial data-structure. Similarly, the <a class="el" href="classCGAL_1_1Linear__cell__complex__for__generalized__map.html"><code>Linear_cell_complex_for_generalized_map&lt;d,d2,LCCTraits,Items,Alloc&gt;</code></a> class is a model of the <code><a class="el" href="classLinearCellComplex.html" title="The concept LinearCellComplex represents a linear cell complex in dimension d, in an ambient space of...">LinearCellComplex</a></code> concept that uses a generalized map as underlying combinatorial data-structure. These two classes guarantee that each vertex is associated with an attribute containing a point. These classes can be used in geometric algorithms (they play the same role as <code>Polyhedron_3</code> for Halfedge Data Structures).</p>
<p>These classes has five template parameters standing for the dimension of the map, the dimension of the ambient space, a traits class (a model of the <code><a class="el" href="classLinearCellComplexTraits.html" title="Required types and functors for the LinearCellComplexTraits concept. This geometric traits concept is...">LinearCellComplexTraits</a></code> concept, see Section <a class="el" href="#sseclcctraits">Linear Cell Complex Traits</a>), an items class (a model of the <code><a class="el" href="classLinearCellComplexItems.html" title="The concept LinearCellComplexItems refines the concept of GenericMapItems by adding the requirement t...">LinearCellComplexItems</a></code> concept, see Section <a class="el" href="#sseclccitem">Linear Cell Complex Items</a>), and an allocator which must be a model of the allocator concept of STL. Default classes are provided for the traits, items, and for the allocator classes, and by default <code>d2=d</code>.</p>
<p>A linear cell complex is valid, if it is a valid combinatorial or generalized map where each dart is associated with an attribute containing a point (i.e. an instance of a model of the <code><a class="el" href="classCellAttributeWithPoint.html" title="The concept CellAttributeWithPoint is a refinement of the CellAttribute concept, to represent a cell ...">CellAttributeWithPoint</a></code> concept). Note that there are no validity constraints on the geometry (test on self intersection, planarity of 2-cells...). We can see two examples of <code><a class="el" href="classCGAL_1_1Linear__cell__complex__for__combinatorial__map.html" title="The class Linear_cell_complex_for_combinatorial_map represents a linear cell complex in dimension d,...">Linear_cell_complex_for_combinatorial_map</a></code> in <a class="el" href="#fig__fig_lcc_instantiations">fig__fig_lcc_instantiations</a>.</p>
<p><a class="anchor" id="fig__fig_lcc_instantiations"></a> </p><div class="image">
<object type="image/svg+xml" data="lcc_instantiations.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="#fig__fig_lcc_instantiations">fig__fig_lcc_instantiations</a> Examples of <code><a class="el" href="classCGAL_1_1Linear__cell__complex__for__combinatorial__map.html" title="The class Linear_cell_complex_for_combinatorial_map represents a linear cell complex in dimension d,...">Linear_cell_complex_for_combinatorial_map</a></code>. Gray disks show the attributes associated to vertices. Associations between darts and attributes are drawn by small lines between darts and disks. <b>Left:</b> Example of <code><a class="el" href="classCGAL_1_1Linear__cell__complex__for__combinatorial__map.html" title="The class Linear_cell_complex_for_combinatorial_map represents a linear cell complex in dimension d,...">Linear_cell_complex_for_combinatorial_map</a>&lt;2,2&gt;</code>. <b>Right:</b> Example of <code><a class="el" href="classCGAL_1_1Linear__cell__complex__for__combinatorial__map.html" title="The class Linear_cell_complex_for_combinatorial_map represents a linear cell complex in dimension d,...">Linear_cell_complex_for_combinatorial_map</a>&lt;3,3&gt;</code>. </p> </div> <p> <br  />
</p>
<h2><a class="anchor" id="Linear_cell_complexCellAttributes"></a>
Cell Attributes</h2>
<p><a class="anchor" id="ssecattributewp"></a> The <code><a class="el" href="classCGAL_1_1Cell__attribute__with__point.html" title="The class Cell_attribute_with_point represents an attribute containing a point and containing an info...">Cell_attribute_with_point</a>&lt;LCC,Info_,Tag,OnMerge,OnSplit&gt;</code> class is a model of the <code><a class="el" href="classCellAttributeWithPoint.html" title="The concept CellAttributeWithPoint is a refinement of the CellAttribute concept, to represent a cell ...">CellAttributeWithPoint</a></code> concept, which is a refinement of the <code>CellAttribute</code> concept. It represents an attribute associated with a cell, which can contain an information (depending on whether <code>Info_==void</code> or not), but which always contains a point, an instance of <a class="el" href="classLinearCellComplex.html#aafe7703196b62bce46a907a289d515f6"><code>LCC::Point</code></a>.</p>
<h2><a class="anchor" id="Linear_cell_complexLinearCellComplexTraits"></a>
Linear Cell Complex Traits</h2>
<p><a class="anchor" id="sseclcctraits"></a> The <code><a class="el" href="classLinearCellComplexTraits.html" title="Required types and functors for the LinearCellComplexTraits concept. This geometric traits concept is...">LinearCellComplexTraits</a></code> geometric traits concept defines the required types and functors used in the <code><a class="el" href="classCGAL_1_1Linear__cell__complex__for__combinatorial__map.html" title="The class Linear_cell_complex_for_combinatorial_map represents a linear cell complex in dimension d,...">Linear_cell_complex_for_combinatorial_map</a></code> class. For example it defines <a class="el" href="classLinearCellComplexTraits.html#a08aa2768df7731ea33a55103dad927b9"><code>Point</code></a>, the type of points used, and <a class="el" href="classLinearCellComplexTraits.html#a533e357e4050159a6fda9fedfd5d88a1"><code>Vector</code></a>, the corresponding vector type. It also defines all the required functors used for constructions and operations, as for example <a class="el" href="classLinearCellComplexTraits.html#aeede6f32b68ccc7919bd331ec07aa459"><code>Construct_translated_point</code></a> or <a class="el" href="classLinearCellComplexTraits.html#a3fa01a5556247923aae1ef71efff844a"><code>Construct_sum_of_vectors</code></a>.</p>
<p>The class <code><a class="el" href="structCGAL_1_1Linear__cell__complex__traits.html" title="This geometric traits concept is used in the Linear_cell_complex_for_combinatorial_map and Linear_cel...">Linear_cell_complex_traits</a>&lt;d,K&gt;</code> is a model of <code><a class="el" href="classLinearCellComplexTraits.html" title="Required types and functors for the LinearCellComplexTraits concept. This geometric traits concept is...">LinearCellComplexTraits</a></code>. It defines the different types which are obtained from <code>K</code> that, depending on <code>d</code>, is a model of the concept <code>Kernel</code> if <code>d==2</code> or <code>d==3</code>, and a model of the concept <code>Kernel_d</code> otherwise.</p>
<h2><a class="anchor" id="Linear_cell_complexLinearCellComplexItems"></a>
Linear Cell Complex Items</h2>
<p><a class="anchor" id="sseclccitem"></a> The <code><a class="el" href="classLinearCellComplexItems.html" title="The concept LinearCellComplexItems refines the concept of GenericMapItems by adding the requirement t...">LinearCellComplexItems</a></code> concept refines the <code>GenericMapItems</code> concept by adding the requirement that 0-attributes are enabled, and associated with a type of attribute being a model of the <code><a class="el" href="classCellAttributeWithPoint.html" title="The concept CellAttributeWithPoint is a refinement of the CellAttribute concept, to represent a cell ...">CellAttributeWithPoint</a></code> concept. Like for combinatorial and generalized maps, it is possible to use indices instead of handles as descriptors, by defining CGAL::Tag_true for Use_index type in the item class.</p>
<p>The class <code><a class="el" href="structCGAL_1_1Linear__cell__complex__min__items.html" title="The class Linear_cell_complex_min_items defines void as the information associated with darts,...">Linear_cell_complex_min_items</a>&lt;d&gt;</code> is a model of <code><a class="el" href="classLinearCellComplexItems.html" title="The concept LinearCellComplexItems refines the concept of GenericMapItems by adding the requirement t...">LinearCellComplexItems</a></code>. It defines <code>void</code> as information associated to darts, and instances of <code><a class="el" href="classCGAL_1_1Cell__attribute__with__point.html" title="The class Cell_attribute_with_point represents an attribute containing a point and containing an info...">Cell_attribute_with_point</a></code> (which contain no information) associated to each vertex. All other attributes are <code>void</code>.</p>
<h1><a class="anchor" id="Linear_cell_complexOperations"></a>
Operations</h1>
<p>Several operations defined in the combinatorial maps or generalized maps package can be used on a linear cell complex. This is the case for all the iteration operations that do not modify the model (see example in Section <a class="el" href="#ssec3Dlcc">A 3D Linear Cell Complex</a>). This is also the case for all the operations that do not create new 0-cells: <code>sew</code>, <code>unsew</code>, <a class="el" href=""><code>remove_cell</code></a>, <a class="el" href=""><code>insert_cell_1_in_cell_2</code></a>, <a class="el" href=""><code>insert_cell_1_between_two_cells_2</code></a> or <a class="el" href=""><code>insert_cell_2_in_cell_3</code></a>. Indeed, all these operations update non <code>void</code> attributes, and thus update vertex attributes of a linear cell complex. Note that some existing 0-attributes can be duplicated by the <code>unsew</code> method, but these 0-attributes are not new but copies of existing old 0-attributes.</p>
<p>However, operations that create a new 0-cell can not be directly used since the new 0-cell would not be associated with a vertex attribute. Indeed, it is not possible for these operations to automatically decide which point to create. These operations are: <a class="el" href=""><code>insert_cell_0_in_cell_1</code></a>, <a class="el" href=""><code>insert_cell_0_in_cell_2</code></a>, <a class="el" href=""><code>insert_dangling_cell_1_in_cell_2</code></a>, plus all the creation operations. For these operations, new versions are proposed taking some points as additional parameters. Lastly, some new operations are defined, which use the geometry (see sections <a class="el" href="#ssecconstructionsop">Construction Operations</a> and <a class="el" href="#ssecmodifop">Modification Operations</a>).</p>
<p>All the operations given in this section guarantee that given a valid linear cell complex and a possible operation, the result is a valid linear cell complex. As for a combinatorial or generalized map, it is also possible to use low level operations but additional operations may be needed to restore the validity conditions.</p>
<h2><a class="anchor" id="sseclcclinkdarts"></a>
Sewing and Unsewing</h2>
<p>As explained in the combinatorial map and generalized map user manuals, it is possible to glue two <em>i</em>-cells along an (<em>i</em>-1)-cell by using the <code>sew&lt;i&gt;</code> method. Since this method updates non void attributes, and since points are specific attributes, they are automatically updated during the <code>sew&lt;i&gt;</code> method. Thus the sewing of two <em>i</em>-cells could deform the geometry of the concerned objects.</p>
<p>For example, in <a class="el" href="#fig__fig_lcc_example_3d_sew">fig__fig_lcc_example_3d_sew</a>, we want to 3-sew the two initial 3-cells. <a class="el" href=""><code>sew&lt;3&gt;(1,5)</code></a> links by \( \beta_3\) the pairs of darts (1,5), (2,8), (3,7) and (4,6). The eight vertex attributes around the facet between the two 3-cells before the sew are merged by pair during the sew operation (and the <a class="el" href=""><code>On_merge</code></a> functor is called four times). Thus, after the sew, there are only four 0-attributes around the facet. By default, the attributes associated with the first dart of the sew operation are kept (but this can be modified by defining your own functor in the attribute class as explained in the packages combinatorial map and generalized map. Intuitively, the geometry of the second 2-cell is deformed to fit to the first 2-cell.</p>
<p><a class="anchor" id="fig__fig_lcc_example_3d_sew"></a> </p><div class="image">
<object type="image/svg+xml" data="lcc_example_3d_sew.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="#fig__fig_lcc_example_3d_sew">fig__fig_lcc_example_3d_sew</a> Example of 3-sew operation for linear cell complex. <b>Left</b>: A 3D linear cell complex containing two 3-cells that are not connected. Vertex attributes are drawn with circles containing point coordinates. Associations between darts and attributes are drawn with small lines between darts and disks. <b>Right</b>: The 3D linear cell complex obtained as result of <a class="el" href=""><code>sew&lt;3&gt;(1,5)</code></a> (or <a class="el" href=""><code>sew&lt;3&gt;(2,8)</code></a>, or <a class="el" href=""><code>sew&lt;3&gt;(3,7)</code></a>, or <a class="el" href=""><code>sew&lt;3&gt;(4,6)</code></a>). The eight 0-attributes around the facet between the two 3-cells before the sew operation, are merged into four 0-attributes after. The geometry of the pyramid is deformed since its base is fitted on the 2-cell of the cube. </p> </div> <p> <br  />
</p>
<p>This is similar for <code>unsew&lt;i&gt;</code> operation, which removes <em>i</em>-links of all the darts in a given <em>(i-1)</em>-cell, and updates non void attributes which are no more associated to a same cell due to the unlinks. If we take the linear cell complex given in <a class="el" href="#fig__fig_lcc_example_3d_sew">fig__fig_lcc_example_3d_sew</a> (Right), and we call <a class="el" href=""><code>unsew&lt;3&gt;(2)</code></a>, we obtain the linear cell complex in <a class="el" href="#fig__fig_lcc_example_3d_sew">fig__fig_lcc_example_3d_sew</a> (Left) except for the coordinates of the new four vertices, which by default are copies of original vertices (this behavior can be modified thanks to the functor <a class="el" href=""><code>On_split</code></a> in the attribute class). The <a class="el" href=""><code>unsew&lt;3&gt;</code></a> operation has removed the four \( \beta_3\) links, and has duplicated the 0-attributes since vertices are split in two after the unsew operation.</p>
 <div class="CGALAdvanced"> <div>Advanced</div> <p>If <a class="el" href=""><code>set_automatic_attributes_management(false)</code></a> is called, all the future sew and unsew operations will not update non void attributes. These attributes will be updated latter by the call to <a class="el" href=""><code>set_automatic_attributes_management(true)</code></a>. </p> </div> <h2><a class="anchor" id="Linear_cell_complexConstructionOperations"></a>
Construction Operations</h2>
<p><a class="anchor" id="ssecconstructionsop"></a> There are several member functions allowing to insert specific configurations of darts into a linear cell complex. These functions return a <code>Dart_descriptor</code> to the new object. Note that the dimension of the linear cell complex must be large enough: darts must contain all the applications ( \( \alpha\) or \( \beta\)) used by the operation. All these methods add new darts in the current linear cell complex, existing darts are not modified. These functions are <a class="el" href="classLinearCellComplex.html#a7638adc553e3a45a5c9c326fb38305b0"><code>make_segment</code></a>, <a class="el" href="classLinearCellComplex.html#ae6aafec384a2351eb0f6be3f372a3262"><code>make_triangle</code></a>, <a class="el" href="classLinearCellComplex.html#a8000bcbd9fb43a0a21d416331a088b3c"><code>make_tetrahedron</code></a> and <a class="el" href="classLinearCellComplex.html#a8791192d04bc27263ee8a694e4515d73"><code>make_hexahedron</code></a>.</p>
<p>There are two functions allowing to build a linear cell complex from two other CGAL data types: </p><ul>
<li>
<a class="el" href="group__PkgLinearCellComplexConstructions.html#ga75b167e60b6cf3adbe8026256bee47ed"><code>import_from_triangulation_3(lcc,atr)</code></a>: adds in <code>lcc</code> all the tetrahedra present in <code>atr</code>, a <a class="el" href=""><code>Triangulation_3</code></a>; </li>
<li>
<a class="el" href="group__PkgLinearCellComplexConstructions.html#gab7a03aa3f1e7e1ff6d15a31e34abb432"><code>import_from_polyhedron_3(lcc,ap)</code></a>: adds in <code>lcc</code> all the cells present in <code>ap</code>, a <code>Polyhedron_3</code>. </li>
</ul>
<p>Lastly, the function <a class="el" href="group__PkgLinearCellComplexConstructions.html#ga2e694849af5a899bb8545ff7ea8ab2a8"><code>import_from_plane_graph(lcc,ais)</code></a> adds in <code>lcc</code> all the cells reconstructed from the planar graph read in <code>ais</code>, a <code>std::istream</code> (see the <a class="el" href="group__PkgLinearCellComplexConstructions.html#ga2e694849af5a899bb8545ff7ea8ab2a8"><code>reference manual</code></a> for the file format).</p>
<h2><a class="anchor" id="Linear_cell_complexModificationOperations"></a>
Modification Operations</h2>
<p><a class="anchor" id="ssecmodifop"></a> Some methods are defined in <code><a class="el" href="classLinearCellComplex.html" title="The concept LinearCellComplex represents a linear cell complex in dimension d, in an ambient space of...">LinearCellComplex</a></code> to modify a linear cell complex and update the vertex attributes. In the following, we denote by <code>d0</code>, <code>d1</code>, <code>d2</code> for three dart descriptors.</p>
<p><a class="anchor" id="fig__fig_lcc_insert_vertex"></a> </p><div class="image">
<object type="image/svg+xml" data="lcc_insert_vertex.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="#fig__fig_lcc_insert_vertex">fig__fig_lcc_insert_vertex</a> Example of <a class="el" href="classLinearCellComplex.html#a4f5cc66cf0e3ad56f6ac6b8804019411"><code>insert_barycenter_in_cell&lt;1&gt;</code></a> and <code>remove_cell&lt;0&gt;</code> operations. <b>Left</b>: Initial linear cell complex. <b>Right</b>: After the insertion of a point in the barycenter of the 1-cell containing dart <em>d1</em>. Now if we remove the 0-cell containing dart <em>d2</em>, we obtain a linear cell complex isomorphic to the initial one. </p> </div> <p> <br  />
</p>
<p><a class="el" href="classLinearCellComplex.html#a4f5cc66cf0e3ad56f6ac6b8804019411"><code>lcc.insert_barycenter_in_cell&lt;unsigned int i&gt;(d0)</code></a> adds the barycenter of the <em>i</em>-cell containing dart <code>d0</code>. This operation is possible if <code>d0</code> \( \in\)<a class="el" href=""><code>lcc.darts()</code></a> (see examples on <a class="el" href="#fig__fig_lcc_insert_vertex">fig__fig_lcc_insert_vertex</a> and <a class="el" href="#fig__fig_lcc_triangulation">fig__fig_lcc_triangulation</a>).</p>
<p><a class="el" href="classLinearCellComplex.html#a7acb1546fe77563b258b1bc9b40f7dba"><code>lcc.insert_point_in_cell&lt;unsigned int i&gt;(d0,p)</code></a> is an operation similar to the previous operation, the only difference being that the coordinates of the new point are here given by <code>p</code> instead of being computed as the barycenter of the <em>i</em>-cell. Currently, these two operations are only defined for <code>i=1</code> to insert a point in an edge, or <code>i=2</code> to insert a point in a facet.</p>
<p><a class="anchor" id="fig__fig_lcc_triangulation"></a> </p><div class="image">
<object type="image/svg+xml" data="lcc_triangulation.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="#fig__fig_lcc_triangulation">fig__fig_lcc_triangulation</a> Examples of <a class="el" href="classLinearCellComplex.html#a4f5cc66cf0e3ad56f6ac6b8804019411"><code>insert_barycenter_in_cell&lt;2&gt;</code></a> operation. </p> </div> <p> <br  />
</p>
<p><a class="el" href="classLinearCellComplex.html#a1e0efc3b39547d957503aadfc2a16fb8"><code>lcc.insert_dangling_cell_1_in_cell_2(d0,p)</code></a> adds a 1-cell in the 2-cell containing dart <code>d0</code>, the 1-cell being attached by only one of its vertex to the 0-cell containing dart <code>d0</code>. The second vertex of the new edge is associated with a new 0-attribute containing a copy of <code>p</code> as point. This operation is possible if <code>d0</code> \( \in\)<a class="el" href=""><code>lcc.darts()</code></a> (see example on <a class="el" href="#fig__fig_lcc_insert_edge">fig__fig_lcc_insert_edge</a>).</p>
<p><a class="anchor" id="fig__fig_lcc_insert_edge"></a> </p><div class="image">
<object type="image/svg+xml" data="lcc_insert_edge.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="#fig__fig_lcc_insert_edge">fig__fig_lcc_insert_edge</a> Example of <a class="el" href="classLinearCellComplex.html#a1e0efc3b39547d957503aadfc2a16fb8"><code>insert_dangling_cell_1_in_cell_2</code></a>, <code>insert_cell_1_in_cell_2</code> and <code>remove_cell&lt;1&gt;</code> operations. <b>Left</b>: Initial linear cell complex. <b>Right</b>: After the insertion of a dangling 1-cell in the 2-cell containing dart <em>d1</em>, and of a 1-cell in the 2-cell containing dart <em>d2</em>. Now if we remove the 1-cells containing dart <em>d4</em> and <em>d5</em>, we obtain a linear cell complex isomorphic to the initial one. </p> </div> <p> <br  />
</p>
<p>Some examples of use of these operations are given in Section <a class="el" href="#ssec5dexample">A 4D Linear Cell Complex</a>.</p>
 <div class="CGALAdvanced"> <div>Advanced</div> <p>If <a class="el" href=""><code>set_automatic_attributes_management(false)</code></a> is called, all the future insertion or removal operations will not update non void attributes. These attributes will be updated latter by the call to <a class="el" href=""><code>set_automatic_attributes_management(true)</code></a>. This can be useful to speed up an algorithm which uses several successive insertion and removal operations. See example <a class="el" href="#ssecAttributesManagement">Automatic attributes management</a>. </p> </div> <h2><a class="anchor" id="Linear_cell_complexIncrementalBuilder"></a>
Incremental Builder</h2>
<p>A utility class <code><a class="el" href="classCGAL_1_1Linear__cell__complex__incremental__builder__3.html" title="The auxiliary class Linear_cell_complex_incremental_builder_3 supports the incremental construction o...">Linear_cell_complex_incremental_builder_3</a></code> helps in creating 2D and 3D linear cell complexes from a list of points followed by a list of facets that are represented as indices into the point list. Note that, compared to <code>Polyhedron_incremental_builder_3</code> it has only absolute indexing and no rollback mechanism.</p>
<h1><a class="anchor" id="Linear_cell_complexExamples"></a>
Examples</h1>
<h2><a class="anchor" id="Linear_cell_complexA3DLinearCellComplex"></a>
A 3D Linear Cell Complex</h2>
<p><a class="anchor" id="ssec3Dlcc"></a> This example uses a 3-dimensional linear cell complex based on combinatorial maps. It creates two tetrahedra and displays all the points of the linear cell complex thanks to a <a class="el" href="classLinearCellComplex.html#a311dc07c9279922957257415d45237df"><code>Vertex_attribute_const_range</code></a>. Then, the two tetrahedra are <a class="el" href=""><code>3-sewn</code></a> and we translate all the points of the second tetrahedron along vector <code>v(3,1,1)</code>. Since the two tetrahedra are 3-sewn, this translation moves also the 2-cell of the first tetrahedron shared with the second one. This is illustrated by displaying all the points of each 3-cell. For that we use a <code>std::for_each</code> and the <code>Display_vol_vertices</code> functor.</p>
<p><br  />
<b>File</b> <a class="el" href="Linear_cell_complex_2linear_cell_complex_3_8cpp-example.html">Linear_cell_complex/linear_cell_complex_3.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Linear_cell_complex_for_combinatorial_map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Linear__cell__complex__for__combinatorial__map.html">CGAL::Linear_cell_complex_for_combinatorial_map&lt;3&gt;</a> LCC_3;</div>
<div class="line"><span class="keyword">typedef</span> LCC_3::Dart_descriptor Dart_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> LCC_3::Point           Point;</div>
<div class="line"><span class="keyword">typedef</span> LCC_3::FT              FT;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Functor used to display all the vertices of a given volume.</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> LCC&gt;</div>
<div class="line"><span class="keyword">struct </span>Display_vol_vertices : <span class="keyword">public</span> CGAL::cpp98::unary_function&lt;LCC, void&gt;</div>
<div class="line">{</div>
<div class="line">  Display_vol_vertices(<span class="keyword">const</span> LCC&amp; alcc) :</div>
<div class="line">    lcc(alcc),</div>
<div class="line">    nb_volume(0)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> operator() (<span class="keyword">typename</span> LCC::Dart&amp; d)</div>
<div class="line">  {</div>
<div class="line">    std::cout&lt;&lt;<span class="stringliteral">&quot;Volume &quot;</span>&lt;&lt;++nb_volume&lt;&lt;<span class="stringliteral">&quot; : &quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> LCC::template One_dart_per_incident_cell_range&lt;0,3&gt;::</div>
<div class="line">           const_iterator it=lcc.template one_dart_per_incident_cell&lt;0,3&gt;</div>
<div class="line">           (lcc.dart_descriptor(d)).begin(),</div>
<div class="line">           itend=lcc.template one_dart_per_incident_cell&lt;0,3&gt;</div>
<div class="line">           (lcc.dart_descriptor(d)).end();</div>
<div class="line">         it!=itend; ++it)</div>
<div class="line">    {</div>
<div class="line">      std::cout &lt;&lt; lcc.point(it) &lt;&lt; <span class="stringliteral">&quot;; &quot;</span>;</div>
<div class="line">    }</div>
<div class="line">    std::cout&lt;&lt;std::endl;</div>
<div class="line">  }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">const</span> LCC&amp; lcc;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_volume;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  LCC_3 lcc;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create two tetrahedra.</span></div>
<div class="line">  Dart_descriptor d1 = lcc.make_tetrahedron(Point(-1, 0, 0), Point(0, 2, 0),</div>
<div class="line">                                        Point(1, 0, 0), Point(1, 1, 2));</div>
<div class="line">  Dart_descriptor d2 = lcc.make_tetrahedron(Point(0, 2, -1),</div>
<div class="line">                                        Point(-1, 0, -1),</div>
<div class="line">                                        Point(1, 0, -1),</div>
<div class="line">                                        Point(1, 1, -3));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Display all the vertices of the lcc by iterating on the</span></div>
<div class="line">  <span class="comment">// Vertex_attribute container.</span></div>
<div class="line">  CGAL::IO::set_ascii_mode(std::cout);</div>
<div class="line">  std::cout&lt;&lt;<span class="stringliteral">&quot;Vertices: &quot;</span>;</div>
<div class="line">  <span class="keywordflow">for</span> (LCC_3::Vertex_attribute_const_range::iterator</div>
<div class="line">         v=lcc.vertex_attributes().begin(),</div>
<div class="line">         vend=lcc.vertex_attributes().end();</div>
<div class="line">       v!=vend; ++v)</div>
<div class="line">    std::cout &lt;&lt; lcc.point_of_vertex_attribute(v) &lt;&lt; <span class="stringliteral">&quot;; &quot;</span>;</div>
<div class="line">  std::cout&lt;&lt;std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Display the vertices of each volume by iterating on darts.</span></div>
<div class="line">  std::for_each(lcc.one_dart_per_cell&lt;3&gt;().begin(),</div>
<div class="line">                lcc.one_dart_per_cell&lt;3&gt;().end(),</div>
<div class="line">                Display_vol_vertices&lt;LCC_3&gt;(lcc));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 3-Sew the 2 tetrahedra along one facet</span></div>
<div class="line">  lcc.sew&lt;3&gt;(d1, d2);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Display the vertices of each volume by iterating on darts.</span></div>
<div class="line">  std::for_each(lcc.one_dart_per_cell&lt;3&gt;().begin(),</div>
<div class="line">                lcc.one_dart_per_cell&lt;3&gt;().end(),</div>
<div class="line">                Display_vol_vertices&lt;LCC_3&gt;(lcc));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Translate the second tetrahedra by a given vector</span></div>
<div class="line">  LCC_3::Vector v(3,1,1);</div>
<div class="line">  <span class="keywordflow">for</span> (LCC_3::One_dart_per_incident_cell_range&lt;0,3&gt;::iterator</div>
<div class="line">         it=lcc.one_dart_per_incident_cell&lt;0,3&gt;(d2).begin(),</div>
<div class="line">         itend=lcc.one_dart_per_incident_cell&lt;0,3&gt;(d2).end();</div>
<div class="line">       it!=itend; ++it)</div>
<div class="line">  {</div>
<div class="line">    lcc.point(it)=LCC_3::Traits::Construct_translated_point_3()</div>
<div class="line">      (lcc.point(it),v);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Display the vertices of each volume by iterating on darts.</span></div>
<div class="line">  std::for_each(lcc.one_dart_per_cell&lt;3&gt;().begin(),</div>
<div class="line">                lcc.one_dart_per_cell&lt;3&gt;().end(),</div>
<div class="line">                Display_vol_vertices&lt;LCC_3&gt;(lcc));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// We display the lcc characteristics.</span></div>
<div class="line">  std::cout&lt;&lt;<span class="stringliteral">&quot;LCC characteristics: &quot;</span>;</div>
<div class="line">  lcc.display_characteristics(std::cout) &lt;&lt; <span class="stringliteral">&quot;, valid=&quot;</span> &lt;&lt; lcc.is_valid()</div>
<div class="line">                                         &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="ttc" id="aclassCGAL_1_1Linear__cell__complex__for__combinatorial__map_html"><div class="ttname"><a href="classCGAL_1_1Linear__cell__complex__for__combinatorial__map.html">CGAL::Linear_cell_complex_for_combinatorial_map</a></div><div class="ttdoc">The class Linear_cell_complex_for_combinatorial_map represents a linear cell complex in dimension d,...</div><div class="ttdef"><b>Definition</b> Linear_cell_complex_for_combinatorial_map.h:29</div></div>
</div><!-- fragment --><p>The output is: </p><pre class="fragment">Vertices: 1 1 2; 1 0 0; 0 2 0; -1 0 0; 1 1 -3; 1 0 -1; -1 0 -1; 0 2 -1;
Volume 1 : -1 0 0; 0 2 0; 1 0 0; 1 1 2;
Volume 2 : 0 2 -1; -1 0 -1; 1 0 -1; 1 1 -3;
Volume 1 : -1 0 0; 0 2 0; 1 0 0; 1 1 2;
Volume 2 : 0 2 0; -1 0 0; 1 0 0; 1 1 -3;
Volume 1 : 2 1 1; 3 3 1; 4 1 1; 1 1 2;
Volume 2 : 3 3 1; 2 1 1; 4 1 1; 4 2 -2;
LCC characteristics: #Darts=24, #0-cells=5, #1-cells=9, #2-cells=7, #3-cells=2, #ccs=1, valid=1
</pre><p>The first line gives the points of the linear cell complex before the <a class="el" href=""><code>sew&lt;3&gt;</code></a>. There are eight points, four for each tetrahedron. After the sew, six vertices are merged two by two, thus there are five vertices. We can see the points of each 3-cell (lines Volume 1 and Volume 2) before the sew, after the sew and after the translation of the second volume. We can see that this translation has also modified the three common points between the two 3-cells. The last line shows the number of cells of the linear cell complex, the number of connected components, and finally a Boolean to show the validity of the linear cell complex.</p>
<h2><a class="anchor" id="Linear_cell_complexA4DLinearCellComplex"></a>
A 4D Linear Cell Complex</h2>
<p><a class="anchor" id="ssec5dexample"></a> This example uses a 4-dimensional linear cell complex embedded in a 5-dimensional ambient space and based on generalized maps. It creates two tetrahedra having 5D points and sews the two tetrahedra by \( \beta_4\). Then we use some high level operations, display the number of cells of the linear cell complex, and check its validity. Last we use the reverse operations to get back to the initial configuration.</p>
<p><br  />
<b>File</b> <a class="el" href="Linear_cell_complex_2linear_cell_complex_4_8cpp-example.html">Linear_cell_complex/linear_cell_complex_4.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Linear_cell_complex_for_generalized_map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Linear__cell__complex__for__generalized__map.html">CGAL::Linear_cell_complex_for_generalized_map&lt;4,5&gt;</a> LCC_4;</div>
<div class="line"><span class="keyword">typedef</span> LCC_4::Dart_descriptor Dart_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> LCC_4::Point           Point;</div>
<div class="line"><span class="keyword">typedef</span> LCC_4::Vector          Vector;</div>
<div class="line"><span class="keyword">typedef</span> LCC_4::FT              FT;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  LCC_4 lcc;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create two tetrahedra.</span></div>
<div class="line">  FT p1[5]={ 0, 0, 0, 0, 0}; std::vector&lt;FT&gt; v1(p1,p1+5);</div>
<div class="line">  FT p2[5]={ 0, 2, 0, 0, 0}; std::vector&lt;FT&gt; v2(p2,p2+5);</div>
<div class="line">  FT p3[5]={ 0, 1, 2, 0, 0}; std::vector&lt;FT&gt; v3(p3,p3+5);</div>
<div class="line">  FT p4[5]={ 2, 1, 0, 0, 0}; std::vector&lt;FT&gt; v4(p4,p4+5);</div>
<div class="line">  FT p5[5]={-1, 0, 0, 0, 0}; std::vector&lt;FT&gt; v5(p5,p5+5);</div>
<div class="line">  FT p6[5]={-1, 2, 0, 0, 0}; std::vector&lt;FT&gt; v6(p6,p6+5);</div>
<div class="line">  FT p7[5]={-1, 1, 2, 0, 0}; std::vector&lt;FT&gt; v7(p7,p7+5);</div>
<div class="line">  FT p8[5]={-3, 1, 2, 0, 0}; std::vector&lt;FT&gt; v8(p8,p8+5);</div>
<div class="line"> </div>
<div class="line">  Dart_descriptor d1 = lcc.make_tetrahedron(Point(5, v1.begin(), v1.end()),</div>
<div class="line">                                        Point(5, v2.begin(), v2.end()),</div>
<div class="line">                                        Point(5, v3.begin(), v3.end()),</div>
<div class="line">                                        Point(5, v4.begin(), v4.end()));</div>
<div class="line"> </div>
<div class="line">  Dart_descriptor d2 = lcc.make_tetrahedron(Point(5, v5.begin(), v5.end()),</div>
<div class="line">                                        Point(5, v6.begin(), v6.end()),</div>
<div class="line">                                        Point(5, v7.begin(), v7.end()),</div>
<div class="line">                                        Point(5, v8.begin(), v8.end()));</div>
<div class="line"> </div>
<div class="line">  lcc.display_characteristics(std::cout);</div>
<div class="line">  std::cout&lt;&lt;<span class="stringliteral">&quot;, valid=&quot;</span>&lt;&lt;lcc.is_valid()&lt;&lt;std::endl;</div>
<div class="line"> </div>
<div class="line">  lcc.sew&lt;4&gt;(d1,d2);</div>
<div class="line"> </div>
<div class="line">  lcc.display_characteristics(std::cout);</div>
<div class="line">  std::cout&lt;&lt;<span class="stringliteral">&quot;, valid=&quot;</span>&lt;&lt;lcc.is_valid()&lt;&lt;std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Add one vertex on the middle of the edge containing dart d1.</span></div>
<div class="line">  Dart_descriptor d3 = lcc.insert_barycenter_in_cell&lt;1&gt;(d1);</div>
<div class="line">  assert( lcc.is_valid() );</div>
<div class="line"> </div>
<div class="line">  lcc.display_characteristics(std::cout);</div>
<div class="line">  std::cout&lt;&lt;<span class="stringliteral">&quot;, valid=&quot;</span>&lt;&lt;lcc.is_valid()&lt;&lt;std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Add one edge to cut the face containing dart d3 in two.</span></div>
<div class="line">  Dart_descriptor d4 = lcc.insert_cell_1_in_cell_2(d3, lcc.alpha(d1, 1, 0, 1));</div>
<div class="line">  assert( lcc.is_valid() );</div>
<div class="line"> </div>
<div class="line">  lcc.display_characteristics(std::cout);</div>
<div class="line">  std::cout&lt;&lt;<span class="stringliteral">&quot;, valid=&quot;</span>&lt;&lt;lcc.is_valid()&lt;&lt;std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// We use removal operations to get back to the initial configuration.</span></div>
<div class="line">  lcc.remove_cell&lt;1&gt;(d4);</div>
<div class="line">  assert( lcc.is_valid() );</div>
<div class="line"> </div>
<div class="line">  lcc.remove_cell&lt;0&gt;(d3);</div>
<div class="line">  assert( lcc.is_valid() );</div>
<div class="line"> </div>
<div class="line">  lcc.unsew&lt;4&gt;(d1);</div>
<div class="line"> </div>
<div class="line">  lcc.display_characteristics(std::cout);</div>
<div class="line">  std::cout&lt;&lt;<span class="stringliteral">&quot;, valid=&quot;</span>&lt;&lt;lcc.is_valid()&lt;&lt;std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Linear__cell__complex__for__generalized__map_html"><div class="ttname"><a href="classCGAL_1_1Linear__cell__complex__for__generalized__map.html">CGAL::Linear_cell_complex_for_generalized_map</a></div><div class="ttdoc">The class Linear_cell_complex_for_generalized_map represents a linear cell complex in dimension d,...</div><div class="ttdef"><b>Definition</b> Linear_cell_complex_for_generalized_map.h:29</div></div>
</div><!-- fragment --><p>The output is: </p><pre class="fragment">#Darts=48, #0-cells=8, #1-cells=12, #2-cells=8, #3-cells=2, #4-cells=2, #ccs=2, orientable=true, valid=1
#Darts=48, #0-cells=4, #1-cells=6, #2-cells=4, #3-cells=1, #4-cells=2, #ccs=1, orientable=true, valid=1
#Darts=56, #0-cells=5, #1-cells=7, #2-cells=4, #3-cells=1, #4-cells=2, #ccs=1, orientable=true, valid=1
#Darts=64, #0-cells=5, #1-cells=8, #2-cells=5, #3-cells=1, #4-cells=2, #ccs=1, orientable=true, valid=1
#Darts=48, #0-cells=8, #1-cells=12, #2-cells=8, #3-cells=2, #4-cells=2, #ccs=2, orientable=true, valid=1
</pre><h2><a class="anchor" id="Linear_cell_complexA3DLinearCellComplexwith"></a>
A 3D Linear Cell Complex with Colored Vertices</h2>
<p><a class="anchor" id="ssecexemplecolorvertices"></a> This example illustrates the way to use a 3D linear cell complex by adding another information to vertices. For that, we need to define our own items class. The difference with the <code><a class="el" href="structCGAL_1_1Linear__cell__complex__min__items.html" title="The class Linear_cell_complex_min_items defines void as the information associated with darts,...">Linear_cell_complex_min_items</a></code> class is about the definition of the vertex attribute where we use a <code><a class="el" href="classCGAL_1_1Cell__attribute__with__point.html" title="The class Cell_attribute_with_point represents an attribute containing a point and containing an info...">Cell_attribute_with_point</a></code> with a non <code>void</code> info. In this example, the <em>vertex color</em> is just given by an <code>int</code> (the second template parameter of the <code><a class="el" href="classCGAL_1_1Cell__attribute__with__point.html" title="The class Cell_attribute_with_point represents an attribute containing a point and containing an info...">Cell_attribute_with_point</a></code>). Lastly, we define the <code>Average_functor</code> class in order to set the color of a vertex resulting of the merging of two vertices to the average of the two initial values. This functor is associated with the vertex attribute by passing it as template parameter. Using this items class instead of the default one is done during the instantiation of template parameters of the <code><a class="el" href="classCGAL_1_1Linear__cell__complex__for__combinatorial__map.html" title="The class Linear_cell_complex_for_combinatorial_map represents a linear cell complex in dimension d,...">Linear_cell_complex_for_combinatorial_map</a></code> class.</p>
<p>Now we can use <code>LCC_3</code> in which each vertex is associated with an attribute containing both a point and an information. In the following example, we create two cubes, and set the color of the vertices of the first cube to 1 and of the second cube to 19 (by iterating through two <a class="el" href=""><code>One_dart_per_incident_cell_range&lt;0, 3&gt;</code></a> ranges). Then we <a class="el" href=""><code>3-sew</code></a> the two cubes along one facet. This operation merges some vertices (as in the example of <a class="el" href="#fig__fig_lcc_example_3d_sew">fig__fig_lcc_example_3d_sew</a>). We insert a vertex in the common 2-cell between the two cubes, and set the information of the new 0-attribute to 5. In the last loop, we display the point and the information of each vertex of the linear cell complex.</p>
<p><br  />
<b>File</b> <a class="el" href="Linear_cell_complex_2linear_cell_complex_3_with_colored_vertices_8cpp-example.html">Linear_cell_complex/linear_cell_complex_3_with_colored_vertices.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Linear_cell_complex_for_combinatorial_map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Average_functor</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> CellAttribute&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()(CellAttribute&amp; ca1, CellAttribute&amp; ca2)</div>
<div class="line">  { ca1.info()=(ca1.info()+ ca2.info())/2; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Myitem</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> Refs&gt;</div>
<div class="line">  <span class="keyword">struct </span>Dart_wrapper</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Cell__attribute__with__point.html">CGAL::Cell_attribute_with_point</a>&lt; Refs, int, CGAL::Tag_true,</div>
<div class="line">                                             Average_functor &gt;</div>
<div class="line">    Vertex_attribute;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">typedef</span> std::tuple&lt;Vertex_attribute&gt; Attributes;</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_struct" href="structCGAL_1_1Linear__cell__complex__traits.html">CGAL::Linear_cell_complex_traits</a></div>
<div class="line">&lt;3, CGAL::Exact_predicates_inexact_constructions_kernel&gt; Traits;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Linear__cell__complex__for__combinatorial__map.html">CGAL::Linear_cell_complex_for_combinatorial_map&lt;3,3,Traits,Myitem&gt;</a> LCC_3;</div>
<div class="line"><span class="keyword">typedef</span> LCC_3::Dart_descriptor Dart_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> LCC_3::Point           Point;</div>
<div class="line"><span class="keyword">typedef</span> LCC_3::FT              FT;</div>
<div class="line"> </div>
<div class="line">Dart_descriptor make_iso_cuboid(LCC_3&amp; lcc, <span class="keyword">const</span> Point&amp; basepoint, FT lg)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> lcc.make_hexahedron(basepoint,</div>
<div class="line">                             Traits::Construct_translated_point()</div>
<div class="line">                             (basepoint,Traits::Vector(lg,0,0)),</div>
<div class="line">                             Traits::Construct_translated_point()</div>
<div class="line">                             (basepoint,Traits::Vector(lg,lg,0)),</div>
<div class="line">                             Traits::Construct_translated_point()</div>
<div class="line">                             (basepoint,Traits::Vector(0,lg,0)),</div>
<div class="line">                             Traits::Construct_translated_point()</div>
<div class="line">                             (basepoint,Traits::Vector(0,lg,lg)),</div>
<div class="line">                             Traits::Construct_translated_point()</div>
<div class="line">                             (basepoint,Traits::Vector(0,0,lg)),</div>
<div class="line">                             Traits::Construct_translated_point()</div>
<div class="line">                             (basepoint,Traits::Vector(lg,0,lg)),</div>
<div class="line">                             Traits::Construct_translated_point()</div>
<div class="line">                             (basepoint,Traits::Vector(lg,lg,lg)));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  LCC_3 lcc;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create two iso_cuboids.</span></div>
<div class="line">  Dart_descriptor d1 = make_iso_cuboid(lcc, Point(-2, 0, 0), 1);</div>
<div class="line">  Dart_descriptor d2 = make_iso_cuboid(lcc, Point(0, 0, 0), 1);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set the &quot;color&quot; of all vertices of the first cube to 1.</span></div>
<div class="line">  <span class="keywordflow">for</span> (LCC_3::One_dart_per_incident_cell_range&lt;0, 3&gt;::iterator</div>
<div class="line">         it=lcc.one_dart_per_incident_cell&lt;0,3&gt;(d1).begin(),</div>
<div class="line">         itend=lcc.one_dart_per_incident_cell&lt;0,3&gt;(d1).end(); it!=itend; ++it)</div>
<div class="line">  { lcc.info&lt;0&gt;(it)=1; }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set the &quot;color&quot; of all vertices of the second cube to 19.</span></div>
<div class="line">  <span class="keywordflow">for</span> (LCC_3::One_dart_per_incident_cell_range&lt;0, 3&gt;::iterator it=</div>
<div class="line">         lcc.one_dart_per_incident_cell&lt;0,3&gt;(d2).begin(),</div>
<div class="line">         itend=lcc.one_dart_per_incident_cell&lt;0,3&gt;(d2).end(); it!=itend; ++it)</div>
<div class="line">  { lcc.info&lt;0&gt;(it)=19; }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 3-Sew the two cubes along one facet.</span></div>
<div class="line">  lcc.sew&lt;3&gt;(lcc.beta(d1, 1, 1, 2), lcc.beta(d2, 2));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Barycentric triangulation of the facet between the two cubes.</span></div>
<div class="line">  Dart_descriptor d3=lcc.insert_barycenter_in_cell&lt;2&gt;(lcc.beta(d2, 2));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set the color of the new vertex to 5.</span></div>
<div class="line">  lcc.info&lt;0&gt;(d3)=5;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Display all the vertices of the map.</span></div>
<div class="line">  <span class="keywordflow">for</span> (LCC_3::Vertex_attribute_range::iterator</div>
<div class="line">         it=lcc.vertex_attributes().begin(),</div>
<div class="line">         itend=lcc.vertex_attributes().end();</div>
<div class="line">       it!=itend; ++it)</div>
<div class="line">  {</div>
<div class="line">    std::cout&lt;&lt;<span class="stringliteral">&quot;point: &quot;</span>&lt;&lt;lcc.point_of_vertex_attribute(it)&lt;&lt;<span class="stringliteral">&quot;, &quot;</span>&lt;&lt;<span class="stringliteral">&quot;color: &quot;</span></div>
<div class="line">             &lt;&lt;lcc.info_of_attribute&lt;0&gt;(it)&lt;&lt;std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Cell__attribute__with__point_html"><div class="ttname"><a href="classCGAL_1_1Cell__attribute__with__point.html">CGAL::Cell_attribute_with_point</a></div><div class="ttdoc">The class Cell_attribute_with_point represents an attribute containing a point and containing an info...</div><div class="ttdef"><b>Definition</b> Cell_attribute_with_point.h:23</div></div>
<div class="ttc" id="astructCGAL_1_1Linear__cell__complex__traits_html"><div class="ttname"><a href="structCGAL_1_1Linear__cell__complex__traits.html">CGAL::Linear_cell_complex_traits</a></div><div class="ttdoc">This geometric traits concept is used in the Linear_cell_complex_for_combinatorial_map and Linear_cel...</div><div class="ttdef"><b>Definition</b> Linear_cell_complex_traits.h:21</div></div>
</div><!-- fragment --><p>The output is: </p><pre class="fragment">point: -1 1 1, color: 10
point: -1 0 1, color: 10
point: -2 0 1, color: 1
point: -2 1 1, color: 1
point: -2 1 0, color: 1
point: -1 1 0, color: 10
point: -1 0 0, color: 10
point: -2 0 0, color: 1
point: 1 1 1, color: 19
point: 1 0 1, color: 19
point: -1 0.5 0.5, color: 5
point: 1 1 0, color: 19
point: 1 0 0, color: 19
</pre><p>Before applying the sew operation, the eight vertices of the first cube are colored by <code>1</code>, and the eight vertices of the second cube by <code>19</code>. After the sew operation, there are eight vertices which are merged two by two, and due to the average functor, the color of the four resulting vertices is now 10. Then we insert a vertex in the center of the common 2-cell between the two cubes. The coordinates of this vertex are initialized with the barycenter of the 2-cell (-1,0.5,0.5), and its color is not initialized by the method, thus we set its color manually by using the result of <a class="el" href="classLinearCellComplex.html#a4f5cc66cf0e3ad56f6ac6b8804019411"><code>insert_barycenter_in_cell&lt;2&gt;</code></a> which is a dart incident to the new vertex.</p>
<h2><a class="anchor" id="Linear_cell_complexAutomaticAttributesManagement"></a>
Automatic Attribute Management</h2>
<p><a class="anchor" id="ssecAttributesManagement"></a> The following example illustrates the use of the automatic attributes management for a linear cell complex. An off file is loaded into a 2D linear cell complex embedded in 3D. Then, a certain percentage of edges is removed from the linear cell complex. The same method is applied twice: the first time by using the automatic attributes management (which is the default behaviour) and the second time by calling first <a class="el" href=""><code>set_automatic_attributes_management(false)</code></a> to disable the automatic updating of attributes.</p>
<p>We can observe that the second run is faster than the first one. Indeed, updating attribute for each edge removal give a bigger complexity. Moreover, the gain increases when the percentage of removed edges increases.</p>
<p><br  />
<b>File</b> <a class="el" href="Linear_cell_complex_2linear_cell_complex_3_attributes_management_8cpp-example.html">Linear_cell_complex/linear_cell_complex_3_attributes_management.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Linear_cell_complex_for_combinatorial_map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Linear_cell_complex_constructors.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Linear__cell__complex__for__combinatorial__map.html">CGAL::Linear_cell_complex_for_combinatorial_map&lt;2,3&gt;</a> LCC_3;</div>
<div class="line"><span class="keyword">typedef</span> LCC_3::Dart_descriptor Dart_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> LCC_3::Point           Point;</div>
<div class="line"><span class="keyword">typedef</span> LCC_3::FT              FT;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> load_and_simplify_off(LCC_3&amp; lcc, <span class="keyword">const</span> std::string&amp; filename,</div>
<div class="line">                           <span class="keywordtype">bool</span> updateattribs, <span class="keywordtype">int</span> percent)</div>
<div class="line">{</div>
<div class="line">  std::ifstream ifile(filename.c_str());</div>
<div class="line">  <span class="keywordflow">if</span> (ifile)</div>
<div class="line">  {</div>
<div class="line">    CGAL::load_off(lcc, ifile);</div>
<div class="line">    CGAL::Timer timer;</div>
<div class="line">    Dart_descriptor d;</div>
<div class="line">    std::size_t nb=(lcc.number_of_darts()*percent)/200;</div>
<div class="line">    timer.start();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!updateattribs) lcc.set_automatic_attributes_management(<span class="keyword">false</span>);</div>
<div class="line">    <span class="keywordflow">for</span> (LCC_3::Dart_range::iterator it=lcc.darts().begin(),</div>
<div class="line">           itend=lcc.darts().end(); it!=itend &amp;&amp; nb&gt;0; )</div>
<div class="line">    {</div>
<div class="line">      d=it++;</div>
<div class="line">      <span class="keywordflow">if</span> ( it!=itend &amp;&amp; it==lcc.beta&lt;2&gt;(d) ) ++it;</div>
<div class="line">      lcc.remove_cell&lt;1&gt;(d);</div>
<div class="line">      --nb;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> ( !updateattribs ) lcc.set_automatic_attributes_management(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    timer.stop();</div>
<div class="line">    lcc.display_characteristics(std::cout);</div>
<div class="line">    std::cout&lt;&lt;<span class="stringliteral">&quot;, valid=&quot;</span>&lt;&lt; lcc.is_valid()</div>
<div class="line">             &lt;&lt;<span class="stringliteral">&quot; time: &quot;</span>&lt;&lt;timer.time()&lt;&lt;<span class="stringliteral">&quot; seconds.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> narg, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (narg&gt;1 &amp;&amp; (!strcmp(argv[1],<span class="stringliteral">&quot;-h&quot;</span>) || !strcmp(argv[1],<span class="stringliteral">&quot;-?&quot;</span>)) )</div>
<div class="line">  {</div>
<div class="line">    std::cout&lt;&lt;<span class="stringliteral">&quot;Usage: a.out file.off [percentage]&quot;</span>&lt;&lt;std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::string filename;</div>
<div class="line">  <span class="keywordflow">if</span> ( narg==1 )</div>
<div class="line">  {</div>
<div class="line">    filename=std::string(CGAL::data_file_path(<span class="stringliteral">&quot;meshes/armadillo.off&quot;</span>));</div>
<div class="line">    std::cout&lt;&lt;<span class="stringliteral">&quot;No filename given: use data/armadillo.off by default.&quot;</span>&lt;&lt;std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span> filename=std::string(argv[1]);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> percent = 30; <span class="comment">// remove 30 percent of edges</span></div>
<div class="line">  <span class="keywordflow">if</span> ( narg&gt;2 ) { percent = atoi(argv[2]); }</div>
<div class="line">  std::cout&lt;&lt;percent&lt;&lt;<span class="stringliteral">&quot;% edges to remove.&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"> </div>
<div class="line">  LCC_3 lcc;</div>
<div class="line">  std::cout&lt;&lt;<span class="stringliteral">&quot;Update attribute DURING operations: &quot;</span>;</div>
<div class="line">  load_and_simplify_off(lcc, filename, <span class="keyword">true</span>, percent);</div>
<div class="line"> </div>
<div class="line">  LCC_3 lcc2;</div>
<div class="line">  std::cout&lt;&lt;<span class="stringliteral">&quot;Update attribute AFTER operations: &quot;</span>;</div>
<div class="line">  load_and_simplify_off(lcc2, filename, <span class="keyword">false</span>, percent);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="Linear_cell_complexDraw"></a>
Draw a Linear Cell Complex</h2>
<p><a class="anchor" id="ssecDrawLCC"></a> A linear cell complex can be visualized by calling the <a class="el" href="group__PkgDrawLinearCellComplex.html">CGAL::draw&lt;LCC&gt;() </a> function as shown in the following example. This function opens a new window showing the given linear cell complex. A call to this function is blocking, that is the program continues as soon as the user closes the window.</p>
<p><br  />
<b>File</b> <a class="el" href="Linear_cell_complex_2draw_linear_cell_complex_8cpp-example.html">Linear_cell_complex/draw_linear_cell_complex.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Linear_cell_complex_for_combinatorial_map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/draw_linear_cell_complex.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Linear__cell__complex__for__combinatorial__map.html">CGAL::Linear_cell_complex_for_combinatorial_map&lt;3&gt;</a> LCC;</div>
<div class="line"><span class="keyword">typedef</span> LCC::Dart_descriptor Dart_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> LCC::Point           Point;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  LCC lcc;</div>
<div class="line">  Dart_descriptor d1=</div>
<div class="line">    lcc.make_hexahedron(Point(0,0,0), Point(5,0,0),</div>
<div class="line">                        Point(5,5,0), Point(0,5,0),</div>
<div class="line">                        Point(0,5,4), Point(0,0,4),</div>
<div class="line">                        Point(5,0,4), Point(5,5,4));</div>
<div class="line">  Dart_descriptor d2=</div>
<div class="line">    lcc.make_hexahedron(Point(5,0,0), Point(10,0,0),</div>
<div class="line">                        Point(10,5,0), Point(5,5,0),</div>
<div class="line">                        Point(5,5,4), Point(5,0,4),</div>
<div class="line">                        Point(10,0,4), Point(10,5,4));</div>
<div class="line"> </div>
<div class="line">  lcc.sew&lt;3&gt;(lcc.beta(d1, 1, 1, 2), lcc.beta(d2, 2));</div>
<div class="line"> </div>
<div class="line">  lcc.display_characteristics(std::cout)&lt;&lt;<span class="stringliteral">&quot;, valid=&quot;</span></div>
<div class="line">                                        &lt;&lt;lcc.is_valid()&lt;&lt;std::endl;</div>
<div class="line">  <a class="code hl_function" href="group__PkgDrawLinearCellComplex.html#gaf1430ae5975d4186d8a9a873959826fc">CGAL::draw</a>(lcc);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__PkgDrawLinearCellComplex_html_gaf1430ae5975d4186d8a9a873959826fc"><div class="ttname"><a href="group__PkgDrawLinearCellComplex.html#gaf1430ae5975d4186d8a9a873959826fc">CGAL::draw</a></div><div class="ttdeci">void draw(const LCC &amp;lcc, const GSOptions &amp;gso)</div><div class="ttdoc">opens a new window and draws a linear cell complex.</div></div>
</div><!-- fragment --><p>This function requires <code>CGAL_Qt6</code>, and is only available if the macro <code>CGAL_USE_BASIC_VIEWER</code> is defined. Linking with the cmake target <code>CGAL::CGAL_Basic_viewer</code> will link with <code>CGAL_Qt6</code> and add the definition <code>CGAL_USE_BASIC_VIEWER</code>.</p>
<p><a class="anchor" id="fig__fig_draw_lcc"></a> </p><div class="image">
<img src="draw_lcc.png" alt=""/>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="#fig__fig_draw_lcc">fig__fig_draw_lcc</a> Result of the run of the draw_linear_cell_complex program. A window shows two 3D cubes and allows to navigate through the 3D scene. </p> </div> <p> <br  />
</p>
<h2><a class="anchor" id="Linear_cell_complexIncrementalBuilderExample"></a>
Incremental Builder</h2>
<p>The following example shows the incremental builder.</p>
<p><br  />
<b>File</b> <a class="el" href="Linear_cell_complex_2linear_cell_complex_3_incremental_builder_8cpp-example.html">Linear_cell_complex/linear_cell_complex_3_incremental_builder.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Linear_cell_complex_for_combinatorial_map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Linear_cell_complex_incremental_builder_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/draw_linear_cell_complex.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Linear__cell__complex__for__combinatorial__map.html">CGAL::Linear_cell_complex_for_combinatorial_map&lt;3, 3&gt;</a> LCC_3;</div>
<div class="line"><span class="keyword">using </span>Point=LCC_3::Point;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  LCC_3 lcc;</div>
<div class="line">  <a class="code hl_class" href="classCGAL_1_1Linear__cell__complex__incremental__builder__3.html">CGAL::Linear_cell_complex_incremental_builder_3&lt;LCC_3&gt;</a> ib(lcc);</div>
<div class="line"> </div>
<div class="line">  ib.add_vertex(Point(0,0,0)); <span class="comment">// vertex 0</span></div>
<div class="line">  ib.add_vertex(Point(1,0,0)); <span class="comment">// vertex 1</span></div>
<div class="line">  ib.add_vertex(Point(1,1,0)); <span class="comment">// vertex 2</span></div>
<div class="line">  ib.add_vertex(Point(0,1,0)); <span class="comment">// vertex 3</span></div>
<div class="line"> </div>
<div class="line">  ib.add_vertex(Point(0,1,1)); <span class="comment">// vertex 4</span></div>
<div class="line">  ib.add_vertex(Point(0,0,1)); <span class="comment">// vertex 5</span></div>
<div class="line">  ib.add_vertex(Point(1,0,1)); <span class="comment">// vertex 6</span></div>
<div class="line">  ib.add_vertex(Point(1,1,1)); <span class="comment">// vertex 7</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a cube</span></div>
<div class="line">  ib.begin_surface();</div>
<div class="line">  ib.add_facet({0,1,2,3});   <span class="comment">// Create a new facet version 1: given all of its indices</span></div>
<div class="line">  ib.add_facet({1,0,5,6});</div>
<div class="line">  ib.add_facet({2,1,6,7});</div>
<div class="line">  ib.add_facet({3,2,7,4});</div>
<div class="line">  ib.add_facet({5,4,7,6});</div>
<div class="line"> </div>
<div class="line">  ib.begin_facet();          <span class="comment">// Create a new facet version 2: begin facet</span></div>
<div class="line">  ib.add_vertex_to_facet(0); <span class="comment">// add successively its indices</span></div>
<div class="line">  ib.add_vertex_to_facet(3);</div>
<div class="line">  ib.add_vertex_to_facet(4);</div>
<div class="line">  ib.add_vertex_to_facet(5);</div>
<div class="line">  ib.end_facet();</div>
<div class="line"> </div>
<div class="line">  ib.end_surface();</div>
<div class="line"> </div>
<div class="line">  ib.add_vertex(Point(-1, 0.5, 0.5)); <span class="comment">// vertex 8</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a pyramid, sharing one of its facets with a facet of the cube</span></div>
<div class="line">  ib.begin_surface();</div>
<div class="line">  ib.add_facet({3,0,5,4});</div>
<div class="line">  ib.add_facet({0,3,8});</div>
<div class="line">  ib.add_facet({3,4,8});</div>
<div class="line">  ib.add_facet({4,5,8});</div>
<div class="line">  ib.add_facet({5,0,8});</div>
<div class="line">  ib.end_surface();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  LCC_3::One_dart_per_cell_range&lt;3,3&gt; cells = lcc.one_dart_per_cell&lt;3&gt;();</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> c = cells.begin(); c != cells.end(); ++c) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;a cell&quot;</span>&lt;&lt; std::endl;</div>
<div class="line">    LCC_3::One_dart_per_incident_cell_range&lt;2,3&gt; faces = lcc.one_dart_per_incident_cell&lt;2,3&gt;(c);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> f = faces.begin(); f != faces.end(); ++f) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  a face&quot;</span>&lt;&lt; std::endl;</div>
<div class="line">      LCC_3::One_dart_per_incident_cell_range&lt;0,2&gt; vertices = lcc.one_dart_per_incident_cell&lt;0,2&gt;(f);</div>
<div class="line">      <span class="keywordflow">for</span>(<span class="keyword">auto</span> v = vertices.begin(); v!= vertices.end(); ++v){</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; lcc.point(v) &lt;&lt; std::endl;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Draw the lcc and display its characteristics</span></div>
<div class="line">  lcc.display_characteristics(std::cout)&lt;&lt;std::endl;</div>
<div class="line">  <a class="code hl_function" href="group__PkgDrawLinearCellComplex.html#gaf1430ae5975d4186d8a9a873959826fc">CGAL::draw</a>(lcc);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Linear__cell__complex__incremental__builder__3_html"><div class="ttname"><a href="classCGAL_1_1Linear__cell__complex__incremental__builder__3.html">CGAL::Linear_cell_complex_incremental_builder_3</a></div><div class="ttdoc">The auxiliary class Linear_cell_complex_incremental_builder_3 supports the incremental construction o...</div><div class="ttdef"><b>Definition</b> Linear_cell_complex_incremental_builder_3.h:15</div></div>
</div><!-- fragment --><h2><a class="anchor" id="Linear_cell_complexInsert"></a>
Insert an Edge Between Two Different Faces</h2>
<p>The following example shows the use of <a class="el" href=""><code>insert_cell_1_between_two_cells_2</code></a> operation that inserts an edge between two different faces, thus creating an hole in the first face.</p>
<p><br  />
<b>File</b> <a class="el" href="Linear_cell_complex_2linear_cell_complex_3_insert_8cpp-example.html">Linear_cell_complex/linear_cell_complex_3_insert.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Linear_cell_complex_for_combinatorial_map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Linear_cell_complex_for_generalized_map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/draw_linear_cell_complex.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Linear__cell__complex__for__combinatorial__map.html">CGAL::Linear_cell_complex_for_combinatorial_map&lt;3&gt;</a> LCC1;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Linear__cell__complex__for__generalized__map.html">CGAL::Linear_cell_complex_for_generalized_map&lt;3&gt;</a> LCC2;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> LCC&gt;</div>
<div class="line"><span class="keywordtype">void</span> test()</div>
<div class="line">{</div>
<div class="line">  LCC lcc;</div>
<div class="line">  <span class="keyword">using </span>Point=<span class="keyword">typename</span> LCC::Point;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typename</span> LCC::Dart_descriptor d1=</div>
<div class="line">    lcc.make_hexahedron(Point(0,0,0), Point(5,0,0),</div>
<div class="line">                        Point(5,5,0), Point(0,5,0),</div>
<div class="line">                        Point(0,5,4), Point(0,0,4),</div>
<div class="line">                        Point(5,0,4), Point(5,5,4));</div>
<div class="line">  <span class="keyword">typename</span> LCC::Dart_descriptor d2=</div>
<div class="line">    lcc.make_quadrangle(Point(5,2,2), Point(5,1,2),</div>
<div class="line">                        Point(5,1,1), Point(5,2,1));</div>
<div class="line"> </div>
<div class="line">  lcc.insert_cell_1_between_two_cells_2</div>
<div class="line">    (lcc.template opposite&lt;2&gt;(lcc.next(lcc.next(d1))),</div>
<div class="line">     lcc.next(lcc.next(d2)));</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="group__PkgDrawLinearCellComplex.html#gaf1430ae5975d4186d8a9a873959826fc">CGAL::draw</a>(lcc);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  test&lt;LCC1&gt;();</div>
<div class="line">  test&lt;LCC2&gt;();</div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="fig__fig_lcc_insert"></a> </p><div class="image">
<img src="lcc_insert_example.png" alt=""/>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="#fig__fig_lcc_insert">fig__fig_lcc_insert</a> Result of the run of the linear_cell_complex_3_insert program. A window shows the 3D cube where one face has a hole. </p> </div> <p> <br  />
</p>
<h1><a class="anchor" id="Linear_cell_complexDesign"></a>
Design and Implementation History</h1>
<p>This package was developed by Guillaume Damiand, with the help of Andreas Fabri, S&eacute;bastien Loriot and Laurent Rineau. Monique Teillaud and Bernd G&auml;rtner contributed to the manual. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"/>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</div>
</body>
</html>
