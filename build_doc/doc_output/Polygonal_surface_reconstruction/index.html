<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CGAL 6.0 - Polygonal Surface Reconstruction: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script src="../Manual/cookie.js" type="text/javascript"></script>
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="topics.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()">&#160;
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)"
               onblur="searchBox.OnSearchFieldFocus(false)"
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""/></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.0 - Polygonal Surface Reconstruction
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">User Manual </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_PolygonalSurfaceReconstruction"></a> </p> <div id="autotoc" class="toc"></div> <dl class="section author"><dt>Author</dt><dd>Liangliang Nan</dd></dl>
<h1><a class="anchor" id="secIntro"></a>
Introduction</h1>
<p>This package implements a hypothesis-and-selection based method for piecewise planar object reconstruction from point clouds <a class="el" href="citelist.html#CITEREF_nan2017polyfit">[1]</a>. The method takes as input an unordered point set sampled from a piecewise planar object. The output is a compact and watertight surface mesh interpolating the input point set. The method assumes that all necessary major planes are provided (or can be extracted from the input point set using the shape detection method described in PkgShapeDetection, or any other alternative methods).</p>
<p>The existing surface reconstruction methods available in CGAL (i.e., PkgPoissonSurfaceReconstruction3, PkgAdvancingFrontSurfaceReconstruction, and PkgScaleSpaceReconstruction3) are suitable for point set representing objects described by smooth surfaces. For man-made objects such as buildings, the results are not satisfactory due to the imperfections and complexity of the reconstructed models (i.e., gigantic meshes, missing regions, noises, and undesired structures). This is mainly because these methods tend to closely follow the surface details. The algorithm introduced in this package is intended to produce simplified and watertight surface meshes. It can recover sharp features of the objects, and it can handle a large amount of noise and outliers, complementing other surface reconstruction methods.</p>
<p>A mixed integer programming (MIP) solver is required to solve the constrained optimization problem formulated by the method (see PkgSolverInterface).</p>
<h1><a class="anchor" id="secAlgo"></a>
Algorithm</h1>
<p>Unlike traditional piecewise planar object reconstruction methods that focus on either extracting good geometric primitives or obtaining proper arrangements of primitives, the emphasis of this method lies in intersecting the primitives (i.e. planes) and seeking for an appropriate combination of them to obtain a manifold and watertight polygonal surface model.</p>
<p>The method casts surface reconstruction as a binary labeling problem based on a hypothesizing-and-selection strategy. The reconstruction consists in the following steps:</p><ol type="1">
<li>extract planes from the input point set (can be skipped if planes are known or provided by other means);</li>
<li>generate a set of candidate faces by intersecting the extracted planar primitives;</li>
<li>select an optimal subset of the candidate faces through optimization under hard constraints that enforces the final polygonal surface to be topologically correct.</li>
</ol>
<p><a class="anchor" id="fig__polyfit"></a> </p><div class="image">
<img src="polyfit_pipeline.png" alt=""/>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="#fig__polyfit">fig__polyfit</a> Polygonal surface reconstruction</p>
<p>(a) Input point set; (b) Extracted planar segments; (c) Candidate faces generated by pairwise intersection; (d) Faces selected through optimization; (e) Reconstructed model. </p> </div> <p> <br  />
</p>
<h2><a class="anchor" id="subsecAlgoEnergyTerms"></a>
Energy Terms</h2>
<p>Given \( N \) candidate faces \(F = \{f_i | 1 \leq i \leq N\}\) generated by pairwise intersection, the optimal subset of the candidate faces that best describes the geometry of the object and form a manifold and watertight polygonal surface is selected through optimization.</p>
<p>Let \(X = \{x_i | 1 \leq i \leq N\}\) denote the selection of the faces (i.e., \(f_i\) is chosen if \(x_i = 1\) or not chosen if \(x_i = 0\)), the objective function consists of three energy terms: data-fitting, model complexity, and point coverage.</p>
<ul>
<li>Data-fitting. This term is intended to evaluate the fitting quality of the faces to the point cloud. It is defined to measure a confidence-weighted percentage of points that do not contribute to the final reconstruction.</li>
</ul>
<p class="formulaDsp">
\begin{equation}
    E_f = 1 - \frac{1}{|P|} \sum_{i=1}^N x_i \cdot support(f_i),
    \label{eq:datafitting}
  \end{equation}
</p>
<p>\(|P|\) is the total number of points in \(P\). \(support(f_i)\) is the number of supporting points accounting for an appropriate notion of confidence.</p>
<ul>
<li>Model complexity. This term is to encourage simple structures (i.e., large planar regions). It is defined as the ratio of sharp edges in the model.</li>
</ul>
<p class="formulaDsp">
\begin{equation}
    E_m = \frac{1}{|E|}\sum_{i=1}^{|E|} corner(e_i),
    \label{eq:complexity}
  \end{equation}
</p>
<p>\(|E|\) denotes the total number of pairwise intersections in the candidate face set. \(corner(e_i)\) is an indicator function whose value is determined by the configuration of the two selected faces connected by \(e_i\). \(corner(e_i)\) will have a value of 1 if the faces associated with \(e_i\) introduce a sharp edge in the final model. Otherwise, \(corner(e_i)\) has a zero value meaning the two faces are coplanar.</p>
<ul>
<li>Point coverage. This term is intended to handle missing data. The idea is to keep the unsupported regions (i.e., regions not covered by points) of the final model as small as possible. This term is defined as the ratio of uncovered regions in the model.</li>
</ul>
<p class="formulaDsp">
\begin{equation}
    E_c = \frac{1}{area(M)}\sum_{i=1}^N x_i \cdot (area(f_i) - area(M_i^\alpha)),
    \label{eq:coverage}
  \end{equation}
</p>
<p>Here \(area(M)\), \(area(f_i)\), and \(area(M_i^\alpha)\) denote the surface areas of the final model, a candidate face \(f_i\), and the \(\alpha\)-shape mesh \(M_i^\alpha\) of \(f_i\), respectively. The \(area(M_i^\alpha)\) is to approximate the area of the face covered by the 3D points.</p>
<p>For more details on the energy terms and the formulation, please refer to the original paper <a class="el" href="citelist.html#CITEREF_nan2017polyfit">[1]</a>.</p>
<h2><a class="anchor" id="subsecAlgoFaceSelection"></a>
Face Selection</h2>
<p>With the above energy terms, the optimal set of faces can be obtained by minimizing a weighted sum of these terms under certain hard constraints.</p>
<p class="formulaDsp">
\begin{equation}
    \begin{aligned}
    \underset{\mathbf{X}}{\text{min}} \quad &amp; \lambda_f \cdot E_f + \lambda_m \cdot E_m +  \lambda_c \cdot E_c   \\
    \text{s.t.}                       \quad &amp; \begin{cases}
    \begin{aligned}
    &amp; \sum_{j \in \mathcal{N}(e_i)} {x_j} = 2 \quad \text{or} \quad 0,     &amp;&amp; 1 \leq i \leq |E|   \\
    &amp; x_i \in \{0, 1\},                                                &amp;&amp; 1 \leq i \leq N
    \end{aligned}
    \end{cases}
    \end{aligned}
    \label{eq:optimization}
\end{equation}
</p>
<p>Here \( \sum_{j \in \mathcal{N}(e_i)} {x_j} \) counts the number of faces connected by an edge \( e_i \). This value is enforced to be either 0 or 2, meaning none or two of the faces can be selected. These hard constraints guarantee that each edge of the final model connects only two adjacent faces.</p>
<p><a class="anchor" id="fig__intersection"></a> </p><div class="image">
<img src="intersection.png" alt=""/>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="#fig__intersection">fig__intersection</a> Intersection of two planes</p>
<p>Two planes intersect with each other resulting in four parts (a). (b) to (g) show all possible combinations to ensure a 2-manifold surface. The edge in (b) and (c) connects two co-planar parts, while in (d) to (g) it introduces sharp edges in the final model. </p> </div> <p> <br  />
</p>
<h1><a class="anchor" id="secPSRexamples"></a>
Examples</h1>
<h2><a class="anchor" id="subsecExampleNoInputPlane"></a>
Reconstruction from Point Clouds</h2>
<p>The method assumes that all necessary planes can be extracted from the input point set. The following examples first extract planes from the input point cloud and then reconstruct the surface model. In the first example, the Efficient RANSAC approach is used to extract planes. It is very fast, but not deterministic, as opposed to the region growing approach from the second example that is slower, but more precise and always returns the same result for the same given parameters.</p>
<p><br  />
<b>File</b> <a class="el" href="Polygonal_surface_reconstruction_2polyfit_example_without_input_planes_8cpp-example.html">Polygonal_surface_reconstruction/polyfit_example_without_input_planes.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Efficient_RANSAC.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygonal_surface_reconstruction.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef CGAL_USE_SCIP  </span><span class="comment">// defined (or not) by CMake scripts, do not define by hand</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/SCIP_mixed_integer_program_traits.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> CGAL::SCIP_mixed_integer_program_traits&lt;double&gt;                        MIP_Solver;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#elif defined(CGAL_USE_GLPK)  </span><span class="comment">// defined (or not) by CMake scripts, do not define by hand</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/GLPK_mixed_integer_program_traits.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> CGAL::GLPK_mixed_integer_program_traits&lt;double&gt;                        MIP_Solver;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#if defined(CGAL_USE_GLPK) || defined(CGAL_USE_SCIP)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> CGAL::Exact_predicates_inexact_constructions_kernel                        Kernel;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> Kernel::Point_3                                                                                                Point;</div>
<div class="line"><span class="keyword">typedef</span> Kernel::Vector_3                                                                                        Vector;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Point with normal, and plane index</span></div>
<div class="line"><span class="keyword">typedef</span> boost::tuple&lt;Point, Vector, int&gt;                                                        PNI;</div>
<div class="line"><span class="keyword">typedef</span> std::vector&lt;PNI&gt;                                                                                        Point_vector;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Nth_of_tuple_property_map&lt;0, PNI&gt;                                                Point_map;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Nth_of_tuple_property_map&lt;1, PNI&gt;                                                Normal_map;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Nth_of_tuple_property_map&lt;2, PNI&gt;                                                Plane_index_map;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> CGAL::Shape_detection::Efficient_RANSAC_traits&lt;Kernel, Point_vector, Point_map, Normal_map&gt;     Traits;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> CGAL::Shape_detection::Efficient_RANSAC&lt;Traits&gt;             Efficient_ransac;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Shape_detection::Plane&lt;Traits&gt;                                                Plane;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Shape_detection::Point_to_shape_index_map&lt;Traits&gt;     Point_to_shape_index_map;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span>        <a class="code hl_class" href="classCGAL_1_1Polygonal__surface__reconstruction.html">CGAL::Polygonal_surface_reconstruction&lt;Kernel&gt;</a>                                Polygonal_surface_reconstruction;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Surface_mesh&lt;Point&gt;                                                                        Surface_mesh;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">* This example first extracts planes from the input point cloud</span></div>
<div class="line"><span class="comment">* (using RANSAC with default parameters) and then reconstructs</span></div>
<div class="line"><span class="comment">* the surface model from the planes.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  Point_vector points;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Loads point set from a file.</span></div>
<div class="line">  <span class="keyword">const</span> std::string input_file = (argc &gt; 1) ? argv[1] : <a class="code hl_namespace" href="namespaceCGAL.html">CGAL</a>::data_file_path(<span class="stringliteral">&quot;points_3/cube.pwn&quot;</span>);</div>
<div class="line">  std::ifstream input_stream(input_file.c_str());</div>
<div class="line">  <span class="keywordflow">if</span> (input_stream.fail()) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;failed open file \&#39;&quot;</span> &lt;&lt;input_file &lt;&lt; <span class="stringliteral">&quot;\&#39;&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  input_stream.close();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Loading point cloud: &quot;</span> &lt;&lt; input_file &lt;&lt; <span class="stringliteral">&quot;...&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  CGAL::Timer t;</div>
<div class="line">  t.start();</div>
<div class="line">  <span class="keywordflow">if</span> (!CGAL::IO::read_points(input_file.c_str(), std::back_inserter(points),</div>
<div class="line">                             CGAL::parameters::point_map(Point_map()).normal_map(Normal_map())))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: cannot read file &quot;</span> &lt;&lt; input_file &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; Done. &quot;</span> &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">&quot; points. Time: &quot;</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">&quot; sec.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Shape detection</span></div>
<div class="line">  Efficient_ransac ransac;</div>
<div class="line">  ransac.set_input(points);</div>
<div class="line">  ransac.add_shape_factory&lt;Plane&gt;();</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Extracting planes...&quot;</span>;</div>
<div class="line">  t.reset();</div>
<div class="line">  ransac.detect();</div>
<div class="line"> </div>
<div class="line">  Efficient_ransac::Plane_range planes = ransac.planes();</div>
<div class="line">  std::size_t num_planes = planes.size();</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; Done. &quot;</span> &lt;&lt; num_planes &lt;&lt; <span class="stringliteral">&quot; planes extracted. Time: &quot;</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">&quot; sec.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Stores the plane index of each point as the third element of the tuple.</span></div>
<div class="line">  Point_to_shape_index_map shape_index_map(points, planes);</div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; points.size(); ++i) {</div>
<div class="line">    <span class="comment">// Uses the get function from the property map that accesses the 3rd element of the tuple.</span></div>
<div class="line">    <span class="keywordtype">int</span> plane_index = get(shape_index_map, i);</div>
<div class="line">    points[i].get&lt;2&gt;() = plane_index;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Generating candidate faces...&quot;</span>;</div>
<div class="line">  t.reset();</div>
<div class="line"> </div>
<div class="line">  Polygonal_surface_reconstruction algo(</div>
<div class="line">    points,</div>
<div class="line">    Point_map(),</div>
<div class="line">    Normal_map(),</div>
<div class="line">    Plane_index_map()</div>
<div class="line">  );</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; Done. Time: &quot;</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">&quot; sec.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  Surface_mesh model;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Reconstructing...&quot;</span>;</div>
<div class="line">  t.reset();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (!algo.reconstruct&lt;MIP_Solver&gt;(model)) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot; Failed: &quot;</span> &lt;&lt; algo.error_message() &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::string&amp; output_file(<span class="stringliteral">&quot;without_input_planes_result.off&quot;</span>);</div>
<div class="line">  <span class="keywordflow">if</span> (CGAL::IO::write_OFF(output_file, model))</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; Done. Saved to &quot;</span> &lt;&lt; output_file &lt;&lt; <span class="stringliteral">&quot;. Time: &quot;</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">&quot; sec.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">else</span> {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot; Failed saving file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Also stores the candidate faces as a surface mesh to a file</span></div>
<div class="line">  Surface_mesh candidate_faces;</div>
<div class="line">  algo.output_candidate_faces(candidate_faces);</div>
<div class="line">  <span class="keyword">const</span> std::string&amp; candidate_faces_file(<span class="stringliteral">&quot;without_input_planes_cube_candidate_faces.off&quot;</span>);</div>
<div class="line">  std::ofstream candidate_stream(candidate_faces_file.c_str());</div>
<div class="line">  <span class="keywordflow">if</span> (CGAL::IO::write_OFF(candidate_stream, candidate_faces))</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Candidate faces saved to &quot;</span> &lt;&lt; candidate_faces_file &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div>
<div class="line">{</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;This test requires either GLPK or SCIP.\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif  </span><span class="comment">// defined(CGAL_USE_GLPK) || defined(CGAL_USE_SCIP)</span></div>
<div class="ttc" id="aclassCGAL_1_1Polygonal__surface__reconstruction_html"><div class="ttname"><a href="classCGAL_1_1Polygonal__surface__reconstruction.html">CGAL::Polygonal_surface_reconstruction</a></div><div class="ttdoc">Implementation of the Polygonal Surface Reconstruction method.</div><div class="ttdef"><b>Definition</b> Polygonal_surface_reconstruction.h:58</div></div>
<div class="ttc" id="anamespaceCGAL_html"><div class="ttname"><a href="namespaceCGAL.html">CGAL</a></div><div class="ttdef"><b>Definition</b> Polygonal_surface_reconstruction.txt:1</div></div>
</div><!-- fragment --><p> <br  />
<b>File</b> <a class="el" href="Polygonal_surface_reconstruction_2polyfit_example_with_region_growing_8cpp-example.html">Polygonal_surface_reconstruction/polyfit_example_with_region_growing.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Region_growing/Region_growing.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Region_growing/Point_set.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygonal_surface_reconstruction.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef CGAL_USE_SCIP  </span><span class="comment">// defined (or not) by CMake scripts, do not define by hand</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/SCIP_mixed_integer_program_traits.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> CGAL::SCIP_mixed_integer_program_traits&lt;double&gt; MIP_Solver;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#elif defined(CGAL_USE_GLPK)  </span><span class="comment">// defined (or not) by CMake scripts, do not define by hand</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/GLPK_mixed_integer_program_traits.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> CGAL::GLPK_mixed_integer_program_traits&lt;double&gt;        MIP_Solver;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#if defined(CGAL_USE_GLPK) || defined(CGAL_USE_SCIP)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/range/irange.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> CGAL::Exact_predicates_inexact_constructions_kernel        Kernel;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> Kernel::FT       FT;</div>
<div class="line"><span class="keyword">typedef</span> Kernel::Point_3         Point;</div>
<div class="line"><span class="keyword">typedef</span> Kernel::Vector_3 Vector;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Point with normal, and plane index.</span></div>
<div class="line"><span class="keyword">typedef</span> boost::tuple&lt;Point, Vector, int&gt; PNI;</div>
<div class="line"><span class="keyword">typedef</span> std::vector&lt;PNI&gt; Point_vector;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> CGAL::Nth_of_tuple_property_map&lt;0, PNI&gt;        Point_map;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Nth_of_tuple_property_map&lt;1, PNI&gt;        Normal_map;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Nth_of_tuple_property_map&lt;2, PNI&gt;        Plane_index_map;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Point_map_region_growing = CGAL::Compose_property_map&lt;CGAL::Random_access_property_map&lt;Point_vector&gt;, Point_map &gt;;</div>
<div class="line"><span class="keyword">using </span>Normal_map_region_growing = CGAL::Compose_property_map&lt;CGAL::Random_access_property_map&lt;Point_vector&gt;, Normal_map &gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Region_type = CGAL::Shape_detection::Point_set::Least_squares_plane_fit_region&lt;Kernel, std::size_t, Point_map_region_growing, Normal_map_region_growing&gt;;</div>
<div class="line"><span class="keyword">using </span>Neighbor_query = CGAL::Shape_detection::Point_set::Sphere_neighbor_query&lt;Kernel, std::size_t, Point_map_region_growing&gt;;</div>
<div class="line"><span class="keyword">using </span>Region_growing = CGAL::Shape_detection::Region_growing&lt;Neighbor_query, Region_type&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> CGAL::Surface_mesh&lt;Point&gt;        Surface_mesh;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Polygonal__surface__reconstruction.html">CGAL::Polygonal_surface_reconstruction&lt;Kernel&gt;</a> Polygonal_surface_reconstruction;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">* This example first extracts planes from the input point cloud</span></div>
<div class="line"><span class="comment">* (using region growing) and then reconstructs</span></div>
<div class="line"><span class="comment">* the surface model from the planes.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  Point_vector points;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Load point set from a file.</span></div>
<div class="line">  <span class="keyword">const</span> std::string input_file = (argc &gt; 1) ? argv[1] : <a class="code hl_namespace" href="namespaceCGAL.html">CGAL</a>::data_file_path(<span class="stringliteral">&quot;points_3/cube.pwn&quot;</span>);</div>
<div class="line">  std::ifstream input_stream(input_file.c_str());</div>
<div class="line">  <span class="keywordflow">if</span> (input_stream.fail()) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed open file \&#39;&quot;</span> &lt;&lt; input_file &lt;&lt; <span class="stringliteral">&quot;\&#39;&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  input_stream.close();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Loading point cloud: &quot;</span> &lt;&lt; input_file &lt;&lt; <span class="stringliteral">&quot;...&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  CGAL::Timer t;</div>
<div class="line">  t.start();</div>
<div class="line">  <span class="keywordflow">if</span> (!CGAL::IO::read_points(input_file.c_str(), std::back_inserter(points),</div>
<div class="line">    CGAL::parameters::point_map(Point_map()).normal_map(Normal_map()))) {</div>
<div class="line"> </div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: cannot read file &quot;</span> &lt;&lt; input_file &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; Done. &quot;</span> &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">&quot; points. Time: &quot;</span></div>
<div class="line">    &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">&quot; sec.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Shape detection.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Default parameter values for the data file cube.pwn.</span></div>
<div class="line">  <span class="keyword">const</span> FT          search_sphere_radius = FT(2) / FT(100);</div>
<div class="line">  <span class="keyword">const</span> FT          max_distance_to_plane = FT(2) / FT(1000);</div>
<div class="line">  <span class="keyword">const</span> FT          max_accepted_angle = FT(25);</div>
<div class="line">  <span class="keyword">const</span> std::size_t min_region_size = 200;</div>
<div class="line"> </div>
<div class="line">  Point_map_region_growing point_map_rg(CGAL::make_random_access_property_map(points));</div>
<div class="line">  Normal_map_region_growing normal_map_rg(CGAL::make_random_access_property_map(points));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create instances of the classes Neighbor_query and Region_type.</span></div>
<div class="line">  Neighbor_query neighbor_query(</div>
<div class="line">    boost::irange&lt;std::size_t&gt;(0, points.size()), CGAL::parameters::sphere_radius(search_sphere_radius).point_map(point_map_rg));</div>
<div class="line"> </div>
<div class="line">  Region_type region_type(</div>
<div class="line">    CGAL::parameters::</div>
<div class="line">    maximum_distance(max_distance_to_plane).</div>
<div class="line">    maximum_angle(max_accepted_angle).</div>
<div class="line">    minimum_region_size(min_region_size).</div>
<div class="line">    point_map(point_map_rg).</div>
<div class="line">    normal_map(normal_map_rg));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create an instance of the region growing class.</span></div>
<div class="line">  Region_growing region_growing(</div>
<div class="line">    boost::irange&lt;std::size_t&gt;(0, points.size()), neighbor_query, region_type);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Extracting planes...&quot;</span>;</div>
<div class="line">  std::vector&lt;typename Region_growing::Primitive_and_region&gt; regions;</div>
<div class="line">  t.reset();</div>
<div class="line">  region_growing.detect(std::back_inserter(regions));</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; Done. &quot;</span> &lt;&lt; regions.size() &lt;&lt; <span class="stringliteral">&quot; planes extracted. Time: &quot;</span></div>
<div class="line">    &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">&quot; sec.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Stores the plane index of each point as the third element of the tuple.</span></div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; points.size(); ++i)</div>
<div class="line">    <span class="comment">// Uses the get function from the property map that accesses the 3rd element of the tuple.</span></div>
<div class="line">    points[i].get&lt;2&gt;() = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(get(region_growing.region_map(), i));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Reconstruction.</span></div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Generating candidate faces...&quot;</span>;</div>
<div class="line">  t.reset();</div>
<div class="line">  Polygonal_surface_reconstruction algo(</div>
<div class="line">    points,</div>
<div class="line">    Point_map(),</div>
<div class="line">    Normal_map(),</div>
<div class="line">    Plane_index_map()</div>
<div class="line">  );</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; Done. Time: &quot;</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">&quot; sec.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  Surface_mesh model;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Reconstructing...&quot;</span>;</div>
<div class="line">  t.reset();</div>
<div class="line">  <span class="keywordflow">if</span> (!algo.reconstruct&lt;MIP_Solver&gt;(model)) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed: &quot;</span> &lt;&lt; algo.error_message() &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; Done. Time: &quot;</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">&quot; sec.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Saving...&quot;</span>;</div>
<div class="line">  t.reset();</div>
<div class="line">  <span class="keyword">const</span> std::string&amp; output_file(<span class="stringliteral">&quot;with_region_growing_result.off&quot;</span>);</div>
<div class="line">  <span class="keywordflow">if</span> (CGAL::IO::write_OFF(output_file, model))</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; Done. Saved to &quot;</span> &lt;&lt; output_file &lt;&lt; <span class="stringliteral">&quot;. Time: &quot;</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">&quot; sec.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">else</span> {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot; Failed saving file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div>
<div class="line">{</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;This test requires either GLPK or SCIP.\n&quot;</span>;</div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif  </span><span class="comment">// defined(CGAL_USE_GLPK) || defined(CGAL_USE_SCIP)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="subsecExampleUserProvidedPlanes"></a>
Reconstruction with User-Provided Planes</h2>
<p>The following example shows the reconstruction using user-provided planar segments.</p>
<p><br  />
<b>File</b> <a class="el" href="Polygonal_surface_reconstruction_2polyfit_example_user_provided_planes_8cpp-example.html">Polygonal_surface_reconstruction/polyfit_example_user_provided_planes.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygonal_surface_reconstruction.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef CGAL_USE_SCIP  </span><span class="comment">// defined (or not) by CMake scripts, do not define by hand</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/SCIP_mixed_integer_program_traits.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> CGAL::SCIP_mixed_integer_program_traits&lt;double&gt;                        MIP_Solver;</div>
<div class="line"><span class="preprocessor">#elif defined(CGAL_USE_GLPK)  </span><span class="comment">// defined (or not) by CMake scripts, do not define by hand</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/GLPK_mixed_integer_program_traits.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> CGAL::GLPK_mixed_integer_program_traits&lt;double&gt;                        MIP_Solver;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#if defined(CGAL_USE_GLPK) || defined(CGAL_USE_SCIP)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> CGAL::Exact_predicates_inexact_constructions_kernel                Kernel;</div>
<div class="line"><span class="keyword">typedef</span> Kernel::Point_3                                                                                        Point;</div>
<div class="line"><span class="keyword">typedef</span> Kernel::Vector_3                                                                                Vector;</div>
<div class="line"><span class="keyword">typedef</span>        <a class="code hl_class" href="classCGAL_1_1Polygonal__surface__reconstruction.html">CGAL::Polygonal_surface_reconstruction&lt;Kernel&gt;</a>                        Polygonal_surface_reconstruction;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Surface_mesh&lt;Point&gt;                                                                Surface_mesh;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Point with normal, and plane index</span></div>
<div class="line"><span class="keyword">typedef</span> boost::tuple&lt;Point, Vector, int&gt;                                                PNI;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Nth_of_tuple_property_map&lt;0, PNI&gt;                                        Point_map;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Nth_of_tuple_property_map&lt;1, PNI&gt;                                        Normal_map;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Nth_of_tuple_property_map&lt;2, PNI&gt;                                        Plane_index_map;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">* The following example shows the reconstruction using user-provided</span></div>
<div class="line"><span class="comment">* planar segments stored in PLY format. In the PLY format, a property</span></div>
<div class="line"><span class="comment">* named &quot;segment_index&quot; stores the plane index for each point (-1 if</span></div>
<div class="line"><span class="comment">* the point is not assigned to a plane).</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string input_file = (argc &gt; 1) ? argv[1] : <a class="code hl_namespace" href="namespaceCGAL.html">CGAL</a>::data_file_path(<span class="stringliteral">&quot;points_3/ball.ply&quot;</span>);</div>
<div class="line">  std::ifstream input_stream(input_file.c_str());</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;PNI&gt; points; <span class="comment">// store points</span></div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Loading point cloud: &quot;</span> &lt;&lt; input_file &lt;&lt; <span class="stringliteral">&quot;...&quot;</span>;</div>
<div class="line">  CGAL::Timer t;</div>
<div class="line">  t.start();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (!CGAL::IO::read_PLY_with_properties(input_stream,</div>
<div class="line">                                          std::back_inserter(points),</div>
<div class="line">                                          CGAL::make_ply_point_reader(Point_map()),</div>
<div class="line">                                          CGAL::make_ply_normal_reader(Normal_map()),</div>
<div class="line">                                          std::make_pair(Plane_index_map(), CGAL::PLY_property&lt;int&gt;(<span class="stringliteral">&quot;segment_index&quot;</span>))))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: cannot read file &quot;</span> &lt;&lt; input_file &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; Done. &quot;</span> &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">&quot; points. Time: &quot;</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">&quot; sec.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Generating candidate faces...&quot;</span>;</div>
<div class="line">  t.reset();</div>
<div class="line"> </div>
<div class="line">  Polygonal_surface_reconstruction algo(</div>
<div class="line">    points,</div>
<div class="line">    Point_map(),</div>
<div class="line">    Normal_map(),</div>
<div class="line">    Plane_index_map()</div>
<div class="line">  );</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; Done. Time: &quot;</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">&quot; sec.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  Surface_mesh model;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Reconstructing...&quot;</span>;</div>
<div class="line">  t.reset();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (!algo.reconstruct&lt;MIP_Solver&gt;(model)) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot; Failed: &quot;</span> &lt;&lt; algo.error_message() &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Saves the mesh model</span></div>
<div class="line">    <span class="keyword">const</span> std::string&amp; output_file(<span class="stringliteral">&quot;user_provided_planes_result.off&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (CGAL::IO::write_OFF(output_file, model))</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; Done. Saved to &quot;</span> &lt;&lt; output_file &lt;&lt; <span class="stringliteral">&quot;. Time: &quot;</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">&quot; sec.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot; Failed saving file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div>
<div class="line">{</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;This test requires either GLPK or SCIP.\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif  </span><span class="comment">// defined(CGAL_USE_GLPK) || defined(CGAL_USE_SCIP)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="subsecExampleDetailControl"></a>
Model Complexity Control</h2>
<p>In addition to favoring clean and compact reconstruction results by encouraging large planar regions, the model complexity term also provides control over the model details, i.e., increasing the influence of this term results in fewer details in the reconstructed 3D models.</p>
<p><a class="anchor" id="fig__complexity"></a> </p><div class="image">
<img src="complexity.png" alt=""/>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="#fig__complexity">fig__complexity</a> The effect of the model complexity term</p>
<p>Reconstruction by gradually increasing the influence of the model complexity term. The values under each subfigure are the weights used in the corresponding optimization. </p> </div> <p> <br  />
</p>
<p>The following example shows how to control the model complexity by tuning the weight of the model complexity term.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This example also shows how to reuse the intermediate results from the candidate generation step.</dd></dl>
<p><br  />
<b>File</b> <a class="el" href="Polygonal_surface_reconstruction_2polyfit_example_model_complexity_control_8cpp-example.html">Polygonal_surface_reconstruction/polyfit_example_model_complexity_control.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygonal_surface_reconstruction.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef CGAL_USE_SCIP </span><span class="comment">// defined (or not) by CMake scripts, do not define by hand</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/SCIP_mixed_integer_program_traits.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> CGAL::SCIP_mixed_integer_program_traits&lt;double&gt;                        MIP_Solver;</div>
<div class="line"><span class="preprocessor">#elif defined(CGAL_USE_GLPK) </span><span class="comment">// defined (or not) by CMake scripts, do not define by hand</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/GLPK_mixed_integer_program_traits.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> CGAL::GLPK_mixed_integer_program_traits&lt;double&gt;                        MIP_Solver;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#if defined(CGAL_USE_GLPK) || defined(CGAL_USE_SCIP)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> CGAL::Exact_predicates_inexact_constructions_kernel                Kernel;</div>
<div class="line"><span class="keyword">typedef</span> Kernel::Point_3                                                                                        Point;</div>
<div class="line"><span class="keyword">typedef</span> Kernel::Vector_3                                                                                Vector;</div>
<div class="line"><span class="keyword">typedef</span>        <a class="code hl_class" href="classCGAL_1_1Polygonal__surface__reconstruction.html">CGAL::Polygonal_surface_reconstruction&lt;Kernel&gt;</a>                        Polygonal_surface_reconstruction;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Surface_mesh&lt;Point&gt;                                                                Surface_mesh;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Point with normal, and plane index</span></div>
<div class="line"><span class="keyword">typedef</span> boost::tuple&lt;Point, Vector, int&gt;                                                PNI;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Nth_of_tuple_property_map&lt;0, PNI&gt;                                        Point_map;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Nth_of_tuple_property_map&lt;1, PNI&gt;                                        Normal_map;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Nth_of_tuple_property_map&lt;2, PNI&gt;                                        Plane_index_map;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">* The following example shows how to control the model complexity by</span></div>
<div class="line"><span class="comment">* increasing the influence of the model complexity term.</span></div>
<div class="line"><span class="comment">* In this example, the intermediate results from plane extraction and</span></div>
<div class="line"><span class="comment">* candidate generation are cached and reused.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string input_file = (argc &gt; 1) ? argv[1] : <a class="code hl_namespace" href="namespaceCGAL.html">CGAL</a>::data_file_path(<span class="stringliteral">&quot;points_3/building.ply&quot;</span>);</div>
<div class="line">  std::ifstream input_stream(input_file.c_str());</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;PNI&gt; points; <span class="comment">// store points</span></div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Loading point cloud: &quot;</span> &lt;&lt; input_file &lt;&lt; <span class="stringliteral">&quot;...&quot;</span>;</div>
<div class="line">  CGAL::Timer t;</div>
<div class="line">  t.start();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (!CGAL::IO::read_PLY_with_properties(input_stream,</div>
<div class="line">                                          std::back_inserter(points),</div>
<div class="line">                                          CGAL::make_ply_point_reader(Point_map()),</div>
<div class="line">                                          CGAL::make_ply_normal_reader(Normal_map()),</div>
<div class="line">                                          std::make_pair(Plane_index_map(), CGAL::PLY_property&lt;int&gt;(<span class="stringliteral">&quot;segment_index&quot;</span>))))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: cannot read file &quot;</span> &lt;&lt; input_file &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; Done. &quot;</span> &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">&quot; points. Time: &quot;</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">&quot; sec.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Generating candidate faces...&quot;</span>;</div>
<div class="line">  t.reset();</div>
<div class="line"> </div>
<div class="line">  Polygonal_surface_reconstruction algo(</div>
<div class="line">    points,</div>
<div class="line">    Point_map(),</div>
<div class="line">    Normal_map(),</div>
<div class="line">    Plane_index_map()</div>
<div class="line">  );</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; Done. Time: &quot;</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">&quot; sec.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Reconstruction with complexity control</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Model 1: more detail</span></div>
<div class="line">  Surface_mesh model;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Reconstructing with complexity 0.05...&quot;</span>;</div>
<div class="line">  t.reset();</div>
<div class="line">  <span class="keywordflow">if</span> (!algo.reconstruct&lt;MIP_Solver&gt;(model, 0.8, 0.15, 0.05)) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot; Failed: &quot;</span> &lt;&lt; algo.error_message() &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span> {</div>
<div class="line">       <span class="keyword">const</span> std::string&amp; output_file = <span class="stringliteral">&quot;building_result-0.05.off&quot;</span>;</div>
<div class="line">       <span class="keywordflow">if</span> (CGAL::IO::write_OFF(output_file, model)) {</div>
<div class="line">           std::cout &lt;&lt; <span class="stringliteral">&quot; Done. Saved to &quot;</span> &lt;&lt; output_file &lt;&lt; <span class="stringliteral">&quot;. Time: &quot;</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">&quot; sec.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">       }</div>
<div class="line">       <span class="keywordflow">else</span> {</div>
<div class="line">           std::cerr &lt;&lt; <span class="stringliteral">&quot; Failed saving file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">           <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">       }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Model 2: a little less detail</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Reconstructing with complexity 0.5...&quot;</span>;</div>
<div class="line">  t.reset();</div>
<div class="line">  <span class="keywordflow">if</span> (!algo.reconstruct&lt;MIP_Solver&gt;(model, 0.3, 0.2, 0.5)) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot; Failed: &quot;</span> &lt;&lt; algo.error_message() &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span> {</div>
<div class="line">       <span class="keyword">const</span> std::string&amp; output_file = <span class="stringliteral">&quot;building_result-0.5.off&quot;</span>;</div>
<div class="line">       <span class="keywordflow">if</span> (CGAL::IO::write_OFF(output_file, model))</div>
<div class="line">           std::cout &lt;&lt; <span class="stringliteral">&quot; Done. Saved to &quot;</span> &lt;&lt; output_file &lt;&lt; <span class="stringliteral">&quot;. Time: &quot;</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">&quot; sec.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">       <span class="keywordflow">else</span> {</div>
<div class="line">           std::cerr &lt;&lt; <span class="stringliteral">&quot; Failed saving file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">           <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">       }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Model 3: more less detail</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Reconstructing with complexity 0.7...&quot;</span>;</div>
<div class="line">  t.reset();</div>
<div class="line">  <span class="keywordflow">if</span> (!algo.reconstruct&lt;MIP_Solver&gt;(model, 0.2, 0.1, 0.7)) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot; Failed: &quot;</span> &lt;&lt; algo.error_message() &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; output_file = <span class="stringliteral">&quot;building_result-0.7.off&quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (CGAL::IO::write_OFF(output_file, model)){</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot; Done. Saved to &quot;</span> &lt;&lt; output_file &lt;&lt; <span class="stringliteral">&quot;. Time: &quot;</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">&quot; sec.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot; Failed saving file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div>
<div class="line">{</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;This test requires either GLPK or SCIP.\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif  </span><span class="comment">// defined(CGAL_USE_GLPK) || defined(CGAL_USE_SCIP)</span></div>
</div><!-- fragment --><h1><a class="anchor" id="secPerformances"></a>
Performance</h1>
<h2><a class="anchor" id="subsecComplexity"></a>
The Problem Complexity</h2>
<p>The method is intended for reconstructing single objects with reasonable geometric complexity. The current implementation computes pairwise intersections of the planar segments, which is sufficient but not necessary to ensure topologically accurate reconstructions. Running on large complex objects may result in an extremely large number of candidate faces, and thus a huge integer programming problem to be solved.</p>
<p>The reconstruction time of a single object with moderate complexity is typically within a few seconds. Among the three steps, the face selection step dominates the reconstruction pipeline when the number of candidate faces is large (e.g., more than 5,000).</p>
<h2><a class="anchor" id="subsecSolver"></a>
The Numerical Solver</h2>
<p>The current implementation incorporates two open source solvers: thirdpartyGLPK and thirdpartySCIP (see PkgSolverInterface). It should be noted that GLPK only manages to solve small problems, i.e., objects with reasonably simple structure. In case you are reconstructing more complex objects, you may need to consider more efficient open source solvers (e.g., <a href="https://github.com/coin-or/Cbc">CBC</a>) or even commercial solvers (e.g., <a href="https://www.gurobi.com/">Gurobi</a>, <a href="https://www.ibm.com/analytics/cplex-optimizer">CPLEX</a>). The following table gives a rough idea of the performance of some solvers.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Model   </th><th class="markdownTableHeadCenter">Problem Size <br  />
variables/constraints   </th><th class="markdownTableHeadLeft">Gurobi   </th><th class="markdownTableHeadNone">CBC   </th><th class="markdownTableHeadNone">SCIP   </th><th class="markdownTableHeadNone">GLPK   </th><th class="markdownTableHeadNone">LP_SOLVE    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><img src="model1.png" alt="" class="inline"/>      </td><td class="markdownTableBodyCenter">1244/2660   </td><td class="markdownTableBodyLeft">0.05 sec   </td><td class="markdownTableBodyNone">0.2 sec   </td><td class="markdownTableBodyNone">0.3 sec   </td><td class="markdownTableBodyNone">9 sec   </td><td class="markdownTableBodyNone">15 min    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><img src="model2.png" alt="" class="inline"/>      </td><td class="markdownTableBodyCenter">2582/5420   </td><td class="markdownTableBodyLeft">0.2 sec   </td><td class="markdownTableBodyNone">0.6 sec   </td><td class="markdownTableBodyNone">2.6 sec   </td><td class="markdownTableBodyNone">35 min   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><img src="model3.png" alt="" class="inline"/>      </td><td class="markdownTableBodyCenter">21556/442191   </td><td class="markdownTableBodyLeft">2 sec   </td><td class="markdownTableBodyNone">7.5 sec   </td><td class="markdownTableBodyNone">9 sec   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">-   </td></tr>
</table>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"/>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</div>
</body>
</html>
